// Copyright 2017 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package util is used by the loader program generated by "bqexport".
package util

import (
	"flag"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"go.chromium.org/luci/common/errors"

	pb "infra/libs/bqschema/tabledef"

	"cloud.google.com/go/bigquery"
	"github.com/golang/protobuf/jsonpb"
)

var (
	outDir  = flag.String("dir", "", "(Required) Path to the root output directory.")
	outName = flag.String("name", "", "(Required) Name of the output JSON file.")
)

// Exporter is capable of exporting a "bqschemaupdater" table protobuf using a
// table definition template and a Schema object that is compatible with
// BigQuery's InferSchema method.
type Exporter struct {
	TableDef *pb.TableDef
	Schema   interface{}
}

// Main is the main entry point. It will process the Exporter configuration and
// emit a BigQuery table protobuf to STDOUT on success.
//
// On failure, content may be written to STDERR and the program will exit with
// a non-zero return code.
func (exp *Exporter) Main() {
	flag.Parse()
	switch {
	case *outDir == "":
		log.Fatal("no output directory provided (-dir)")
	case *outName == "":
		log.Fatal("no output filename provided (-name)")
	}

	bqSchema, err := bigquery.InferSchema(exp.Schema)
	if err != nil {
		log.Fatalf("could not generate schema from %T: %s", exp.Schema, err)
	}
	if err := exp.applyTags(exp.Schema, bqSchema); err != nil {
		log.Fatalf("could not apply tags: %s", err)
	}
	exp.TableDef.Fields = SchemaToProto(bqSchema)

	// Create our output directory by appending the dataset ID to the output
	// directory base.
	outPath := filepath.Join(*outDir, exp.TableDef.Dataset.ID(), *outName)
	if err := os.MkdirAll(filepath.Dir(outPath), 0755); err != nil {
		log.Fatalf("failed to create output directory %s: %s", filepath.Dir(outPath), err)
	}

	fd, err := os.Create(outPath)
	if err != nil {
		log.Fatalf("failed to create output file %s: %s", outPath, err)
	}

	marshaler := jsonpb.Marshaler{
		Indent: "  ",
	}
	if err := marshaler.Marshal(fd, exp.TableDef); err != nil {
		fd.Close()
		log.Fatalf("could not marshal proto to JSON: %s", err)
	}

	if err := fd.Close(); err != nil {
		log.Fatalf("failed to close output file: %s", err)
	}
}

func (exp *Exporter) applyTags(typ interface{}, bqSchema bigquery.Schema) error {
	rtyp := reflect.TypeOf(typ)
	for i, field := range bqSchema {
		if err := applyTagsToField(rtyp, field); err != nil {
			return errors.Annotate(err, "failed to apply tags to field #%d / %q", i, field.Name).Err()
		}
	}
	return nil
}

// applyTagsToField extracts the "bqexport" tag value from the struct field
// corresponding to BigQuery schema name "name".
//
// The BigQuery schema name is either:
//	- The value in the "bigquery" tag, if present, or
//	- The actual name of the struct field.
func applyTagsToField(st reflect.Type, field *bigquery.FieldSchema) error {
	// "st" is either:
	// - A slice of structs.
	// - A slice of pointers to structs.
	// - A struct.
	// - A pointer to a struct.
	// - Invalid (will return an error).
	if st.Kind() == reflect.Slice {
		st = st.Elem()
	}
	if st.Kind() == reflect.Ptr {
		st = st.Elem()
	}
	if st.Kind() != reflect.Struct {
		return errors.Reason("record type is not a struct").Err()
	}

	// By default, all fields are not required.
	field.Required = false

	sf := getFieldForBigQueryName(st, field.Name)
	if sf == nil {
		// Could not find associated field.
		return nil
	}

	// Process the "bqexport" tag, if present.
	if tag := sf.Tag.Get("bqexport"); tag != "" {
		for len(tag) > 0 {
			if strings.HasPrefix(tag, "d=") {
				// The remainder of the tag is the field description.
				field.Description = tag[len("d="):]
				break
			}

			parts := strings.SplitN(tag, ",", 2)
			switch v := parts[0]; v {
			case "req":
				field.Required = true
			default:
				return errors.Reason("unknown 'bqexport' tag field %q", v).Err()
			}

			if len(parts) == 2 {
				tag = parts[1]
			} else {
				tag = ""
			}
		}
	}

	// If the field is a RECORD, recurse and apply tags to inner struct.
	if field.Type == bigquery.RecordFieldType {
		for _, subField := range field.Schema {
			if err := applyTagsToField(sf.Type, subField); err != nil {
				return errors.Annotate(err, "could not apply inner schema to %q", subField.Name).Err()
			}
		}
	}

	return nil
}

// getFieldIndexForBigQueryName returns the struct field index for the given
// BigQuery schema name.
//
// The BigQuery schema name is derived from either:
//	- The value in the "bigquery" tag, if present, or
//	- The actual name of the struct field.
func getFieldForBigQueryName(st reflect.Type, name string) *reflect.StructField {
	for i := 0; i < st.NumField(); i++ {
		sf := st.Field(i)

		bqName := sf.Tag.Get("bigquery")
		if bqName == "" {
			bqName = sf.Name
		}
		if bqName == name {
			return &sf
		}
	}

	return nil
}
