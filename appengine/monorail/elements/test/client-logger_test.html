<meta charset="utf-8">
<script src="/bower_components/web-component-tester/browser.js"></script>

<script type="module">
import ClientLogger from '../../static/js/monitoring/client-logger.js';
import MonorailTSMon from '../../static/js/monitoring/ts-mon.js';

suite('ClientLogger', () => {

  setup(() => {
    window.CS_env = {
      token: 'rutabaga-token',
      tokenExpiresSec: 1234,
    };
    window.chops = {rpc: {PrpcClient: sinon.spy()}};
    window.ga = sinon.spy();
    MonorailTSMon.prototype.disableAfterNextFlush = sinon.spy();
  });

  suite('constructor', function() {
    test('assigns this.category', function() {
      const c = new ClientLogger('rutabaga');
      assert.equal(c.category, 'rutabaga');
    });

    test('gets started events from sessionStorage', function() {
      const startedEvents = {
        event1: {
          time: 12345678,
          labels: ['label1', 'label2'],
        },
        event2: {
          time: 87654321,
          labels: ['label2'],
        },
      };
      const key = 'ClientLogger.rutabaga.started';
      sessionStorage[key] = JSON.stringify(startedEvents);

      const c = new ClientLogger('rutabaga');
      assert.deepEqual(startedEvents, c.startedEvents);
    });
  });

  test('records ts_mon metrics', function() {
    window.ga = sinon.spy();
    const c = new ClientLogger('issues');
    const issueCreateMetric = c.tsMon._userTimingMetrics[0].metric;
    issueCreateMetric.add = sinon.spy();
    const issueUpdateMetric = c.tsMon._userTimingMetrics[1].metric;
    issueUpdateMetric.add = sinon.spy();

    c.logStart('rutabaga');
    c.logEnd('rutabaga');
    sinon.assert.notCalled(issueCreateMetric.add);
    sinon.assert.notCalled(issueUpdateMetric.add);
    issueCreateMetric.add.reset();
    issueUpdateMetric.add.reset();

    c.logStart('new-issue');
    c.logEnd('new-issue');
    sinon.assert.calledOnce(issueCreateMetric.add);
    sinon.assert.notCalled(issueUpdateMetric.add);
    issueCreateMetric.add.reset();
    issueUpdateMetric.add.reset();

    c.logStart('issue-update');
    c.logEnd('issue-update');
    sinon.assert.notCalled(issueCreateMetric.add);
    sinon.assert.calledOnce(issueUpdateMetric.add);
  });

  suite('logEnd', () => {
    let c, clock;
    setup(() => {
      c = new ClientLogger('rutabaga');
      clock = sinon.useFakeTimers(1000);
      c.tsMon.recordUserTiming = sinon.spy();
    });

    teardown(() => {
      clock.restore();
    });

    test('throws an error if no event was started', () => {
      c.startedEvents = {someEvent: {}};
      assert.throws(() => {
        c.logEnd('bogus');
      });
      sinon.assert.notCalled(window.ga);
    });

    test('calls ga() with timing and event info', () => {
      c.startedEvents = {someEvent: {time: 900}};
      c.logEnd('someEvent');

      assert.deepEqual(window.ga.getCall(0).args, [
        'send', 'timing', {
          timingCategory: 'rutabaga',
          timingValue: 100,
          timingVar: 'someEvent',
      }]);
      assert.deepEqual(window.ga.getCall(1).args, [
        'send', 'event', 'rutabaga', 'someEvent-end', undefined, undefined
      ]);
      sinon.assert.calledWith(c.tsMon.recordUserTiming, 'rutabaga',
        'someEvent', 100);
    });

    test('does not log events over threshold', () => {
      c.startedEvents = {rutabaga: {time: 900}};
      c.logEnd('rutabaga', null, 99);

      sinon.assert.notCalled(window.ga);
      sinon.assert.notCalled(c.tsMon.recordUserTiming);
    });
  });

});
</script>
