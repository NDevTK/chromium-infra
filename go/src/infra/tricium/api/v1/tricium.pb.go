// Code generated by protoc-gen-go. DO NOT EDIT.
// source: infra/tricium/api/v1/tricium.proto

package tricium

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type State int32

const (
	// Pending is for when an analysis request has been received but the corresponding
	// workflow, analyzer, or workers are not running yet.
	State_PENDING State = 0
	// Running is for when the workflow, analyzer, or workers of a request have been launched
	// but have not finished.
	State_RUNNING State = 1
	// Success is for a workflow, analyzer, or worker that successfully completed.
	//
	// Success of workflows and analyzers, is aggregated from underlying analyzers and workers,
	// where full success means success is aggregated.
	State_SUCCESS State = 2
	// Failure is for a workflow, analyzer, or worker that completed with failure.
	//
	// Failure of workflows and analyzers, is aggregated from underlying analyzers and workers,
	// where any occurrence of failure means failure is aggregated.
	State_FAILURE State = 3
	// Canceled is for user canceled workflows, analyzers, and workers.
	// NB! Not supported yet.
	State_CANCELED State = 4
	// Timed out is for workers where the triggered swarming task timed out.
	// NB! Not supported yet.
	State_TIMED_OUT State = 5
	// Aborted is for workers aborted due to a failing worker dependency.
	//
	// For instance, the worker providing the data needed by a worker may have failed.
	State_ABORTED State = 6
)

var State_name = map[int32]string{
	0: "PENDING",
	1: "RUNNING",
	2: "SUCCESS",
	3: "FAILURE",
	4: "CANCELED",
	5: "TIMED_OUT",
	6: "ABORTED",
}
var State_value = map[string]int32{
	"PENDING":   0,
	"RUNNING":   1,
	"SUCCESS":   2,
	"FAILURE":   3,
	"CANCELED":  4,
	"TIMED_OUT": 5,
	"ABORTED":   6,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

type Consumer int32

const (
	// No consumer means progress and results can be pulled from the Tricium service API.
	//
	// This is the default value used when no consumer is configured for a project.
	Consumer_NONE Consumer = 0
	// A Gerrit consumer means the Tricium service polls Gerrit for changes and reports
	// progress updates and results to Gerrit.
	//
	// Gerrit details need to be configured for a project before the Gerrit consumer
	// option is enabled.
	//
	// Gerrit consumer details must be provided with this option.
	Consumer_GERRIT Consumer = 1
)

var Consumer_name = map[int32]string{
	0: "NONE",
	1: "GERRIT",
}
var Consumer_value = map[string]int32{
	"NONE":   0,
	"GERRIT": 1,
}

func (x Consumer) String() string {
	return proto.EnumName(Consumer_name, int32(x))
}
func (Consumer) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

// AnalyzeRequest contains the details needed for an analysis request.
type AnalyzeRequest struct {
	// Name of the project hosting the paths listed in the request. The name
	// should map to the project name as it is connected to Tricium.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	GitRef  string `protobuf:"bytes,2,opt,name=git_ref,json=gitRef" json:"git_ref,omitempty"`
	// Paths to analyze in the project. Listed from the root of the Git
	// repository.
	// TODO(emso): document path separators or add listing of path segments.
	Paths []string `protobuf:"bytes,3,rep,name=paths" json:"paths,omitempty"`
	// Consumer to send progress updates and results to.
	//
	// This field is optional. If included it will push progress and result
	// updates to the provided consumer. The selected consumer must be
	// configured for the project of the request.
	//
	// Note that progress and results can be accessed via the Tricium
	// API regardless of whether a consumer has been included in the request.
	Consumer Consumer `protobuf:"varint,4,opt,name=consumer,enum=tricium.Consumer" json:"consumer,omitempty"`
	// Gerrit details for a Gerrit consumer.
	GerritDetails *GerritConsumerDetails `protobuf:"bytes,5,opt,name=gerrit_details,json=gerritDetails" json:"gerrit_details,omitempty"`
}

func (m *AnalyzeRequest) Reset()                    { *m = AnalyzeRequest{} }
func (m *AnalyzeRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeRequest) ProtoMessage()               {}
func (*AnalyzeRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *AnalyzeRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *AnalyzeRequest) GetGitRef() string {
	if m != nil {
		return m.GitRef
	}
	return ""
}

func (m *AnalyzeRequest) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *AnalyzeRequest) GetConsumer() Consumer {
	if m != nil {
		return m.Consumer
	}
	return Consumer_NONE
}

func (m *AnalyzeRequest) GetGerritDetails() *GerritConsumerDetails {
	if m != nil {
		return m.GerritDetails
	}
	return nil
}

type AnalyzeResponse struct {
	// ID of the run started for this request.
	//
	// This ID can be used to track progress and request results.
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
}

func (m *AnalyzeResponse) Reset()                    { *m = AnalyzeResponse{} }
func (m *AnalyzeResponse) String() string            { return proto.CompactTextString(m) }
func (*AnalyzeResponse) ProtoMessage()               {}
func (*AnalyzeResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *AnalyzeResponse) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

type ProgressRequest struct {
	// Run ID returned by an analyze request.
	//
	// This field must be provided, unless a consumer is provided below.
	// If nothing else is provided, then all known progress for the run is returned.
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
	// An optional analyzer name.
	//
	// If provided, only progress for the provided analyzer will be returned.
	// The analyzer name should match the name of the analyzer in the Tricium
	// configuration.
	//
	// NB! Currently not supported.
	Analyzer string `protobuf:"bytes,2,opt,name=analyzer" json:"analyzer,omitempty"`
	// Optional platform that may be provided together with an analyzer name.
	//
	// If provided, only progress for the provided analyzer and platform will be provided.
	//
	// NB! Currently not supported.
	Platform *Platform `protobuf:"bytes,3,opt,name=platform" json:"platform,omitempty"`
	// Consumer of the progress information.
	//
	// This field is optional. If included, consumer-specific fields will be considered
	// when looking up progress information and the run ID can be excluded.
	//
	// Note that if a run ID is listed and a consumer. Then the run ID will be used.
	Consumer Consumer `protobuf:"varint,4,opt,name=consumer,enum=tricium.Consumer" json:"consumer,omitempty"`
	// Gerrit details for the Gerrit consumer.
	GerritDetails *GerritConsumerDetails `protobuf:"bytes,5,opt,name=gerrit_details,json=gerritDetails" json:"gerrit_details,omitempty"`
}

func (m *ProgressRequest) Reset()                    { *m = ProgressRequest{} }
func (m *ProgressRequest) String() string            { return proto.CompactTextString(m) }
func (*ProgressRequest) ProtoMessage()               {}
func (*ProgressRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *ProgressRequest) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *ProgressRequest) GetAnalyzer() string {
	if m != nil {
		return m.Analyzer
	}
	return ""
}

func (m *ProgressRequest) GetPlatform() *Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

func (m *ProgressRequest) GetConsumer() Consumer {
	if m != nil {
		return m.Consumer
	}
	return Consumer_NONE
}

func (m *ProgressRequest) GetGerritDetails() *GerritConsumerDetails {
	if m != nil {
		return m.GerritDetails
	}
	return nil
}

type ProgressResponse struct {
	// ID of the run progress is reported for.
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
	// Overall state for the run provided in the progress request.
	State State `protobuf:"varint,2,opt,name=state,enum=tricium.State" json:"state,omitempty"`
	// Analyzer progress matching the requested progress report.
	//
	// For a provided run ID this corresponds to all analyzers and platforms, and
	// for any selection of these, a subset is returned.
	//
	// NB! Selection of a subset is currently not supported.
	AnalyzerProgress []*AnalyzerProgress `protobuf:"bytes,3,rep,name=analyzer_progress,json=analyzerProgress" json:"analyzer_progress,omitempty"`
}

func (m *ProgressResponse) Reset()                    { *m = ProgressResponse{} }
func (m *ProgressResponse) String() string            { return proto.CompactTextString(m) }
func (*ProgressResponse) ProtoMessage()               {}
func (*ProgressResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *ProgressResponse) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *ProgressResponse) GetState() State {
	if m != nil {
		return m.State
	}
	return State_PENDING
}

func (m *ProgressResponse) GetAnalyzerProgress() []*AnalyzerProgress {
	if m != nil {
		return m.AnalyzerProgress
	}
	return nil
}

type AnalyzerProgress struct {
	// The analyzer name.
	Analyzer string `protobuf:"bytes,1,opt,name=analyzer" json:"analyzer,omitempty"`
	// The platform for which the analyzer progress is reported.
	Platform Platform_Name `protobuf:"varint,2,opt,name=platform,enum=tricium.Platform_Name" json:"platform,omitempty"`
	// The state of the analyzer.
	//
	// For an analyzer on a specific platform this state corresponds to the state
	// of the worker, else it is the aggregated state of all workers for the analyzer.
	State State `protobuf:"varint,3,opt,name=state,enum=tricium.State" json:"state,omitempty"`
	// URL to the swarming server running tasks for the workers of the analyzer.
	SwarmingUrl string `protobuf:"bytes,4,opt,name=swarming_url,json=swarmingUrl" json:"swarming_url,omitempty"`
	// The ID of the swarming task triggered for the analyzer worker.
	SwarmingTaskId string `protobuf:"bytes,5,opt,name=swarming_task_id,json=swarmingTaskId" json:"swarming_task_id,omitempty"`
	// Number of comments.
	//
	// For analyzers that are done and produce comments.
	NumComments int32 `protobuf:"varint,6,opt,name=num_comments,json=numComments" json:"num_comments,omitempty"`
}

func (m *AnalyzerProgress) Reset()                    { *m = AnalyzerProgress{} }
func (m *AnalyzerProgress) String() string            { return proto.CompactTextString(m) }
func (*AnalyzerProgress) ProtoMessage()               {}
func (*AnalyzerProgress) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *AnalyzerProgress) GetAnalyzer() string {
	if m != nil {
		return m.Analyzer
	}
	return ""
}

func (m *AnalyzerProgress) GetPlatform() Platform_Name {
	if m != nil {
		return m.Platform
	}
	return Platform_ANY
}

func (m *AnalyzerProgress) GetState() State {
	if m != nil {
		return m.State
	}
	return State_PENDING
}

func (m *AnalyzerProgress) GetSwarmingUrl() string {
	if m != nil {
		return m.SwarmingUrl
	}
	return ""
}

func (m *AnalyzerProgress) GetSwarmingTaskId() string {
	if m != nil {
		return m.SwarmingTaskId
	}
	return ""
}

func (m *AnalyzerProgress) GetNumComments() int32 {
	if m != nil {
		return m.NumComments
	}
	return 0
}

type ResultsRequest struct {
	// Run ID returned by an analyze request.
	RunId string `protobuf:"bytes,1,opt,name=run_id,json=runId" json:"run_id,omitempty"`
	// An optional analyzer name.
	//
	// If provided, only results for the provided analyzer are returned.
	// If an analyzer is being run on more than one platform then the merged
	// results of the analyzer can be returned by exclusion of a specific platform.
	//
	// NB! Currently not supported.
	Analyzer string `protobuf:"bytes,2,opt,name=analyzer" json:"analyzer,omitempty"`
	// Optional platform that can be provided together with an analyzer name.
	//
	// If provided, only results for the provided platform and analyzer are returned.
	//
	// NB! Currently not supported.
	Platform Platform_Name `protobuf:"varint,3,opt,name=platform,enum=tricium.Platform_Name" json:"platform,omitempty"`
}

func (m *ResultsRequest) Reset()                    { *m = ResultsRequest{} }
func (m *ResultsRequest) String() string            { return proto.CompactTextString(m) }
func (*ResultsRequest) ProtoMessage()               {}
func (*ResultsRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func (m *ResultsRequest) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *ResultsRequest) GetAnalyzer() string {
	if m != nil {
		return m.Analyzer
	}
	return ""
}

func (m *ResultsRequest) GetPlatform() Platform_Name {
	if m != nil {
		return m.Platform
	}
	return Platform_ANY
}

type ResultsResponse struct {
	// TODO(emso): Support paging of results to deal with large number of results.
	Results *Data_Results `protobuf:"bytes,1,opt,name=results" json:"results,omitempty"`
	// Whether the returned results are merged.
	//
	// Results may be merged if a result request for an analyzer running on multiple
	// platforms was made and the request did not include a specific platform.
	// Results for a run with no specific analyzer selected will be marked as merged
	// if any included analyzer results were merged.
	IsMerged bool `protobuf:"varint,2,opt,name=is_merged,json=isMerged" json:"is_merged,omitempty"`
}

func (m *ResultsResponse) Reset()                    { *m = ResultsResponse{} }
func (m *ResultsResponse) String() string            { return proto.CompactTextString(m) }
func (*ResultsResponse) ProtoMessage()               {}
func (*ResultsResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

func (m *ResultsResponse) GetResults() *Data_Results {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *ResultsResponse) GetIsMerged() bool {
	if m != nil {
		return m.IsMerged
	}
	return false
}

type FeedbackRequest struct {
	// Analyzer category to provide aggregated feedback for.
	//
	// This includes the analyzer name along with optional subcategories
	// separated with slash, e.g., "ClangTidy" or "ClangTidy/llvm-header-guard".
	//
	// Required field. Must include at least the analyzer name and should not
	// end with a slash.
	Category string `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	// Start of time period to report feedback for.
	//
	// Feedback for comments created from this time will be included.
	// Must be on the form "2006-01-02T08:04:05Z" (RFC 3339) and before end_time.
	//
	// Optional field. Defaults to epoch start of time (Jan 1, 1970).
	StartTime string `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// End of time period to report feedback for.
	//
	// Feedback from comments created before this time will be included.
	// Must be on the form "2006-01-02T08:04:05Z" (RFC 3339) and after start_time.
	//
	// Optional field. Defaults to now.
	EndTime string `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *FeedbackRequest) Reset()                    { *m = FeedbackRequest{} }
func (m *FeedbackRequest) String() string            { return proto.CompactTextString(m) }
func (*FeedbackRequest) ProtoMessage()               {}
func (*FeedbackRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

func (m *FeedbackRequest) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *FeedbackRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *FeedbackRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

type FeedbackResponse struct {
	// Number of returned comments.
	//
	// In any case where an analyzer was run on multiple platforms and the resulting
	// comments were merged, only merged comments are returned in this count. Note that
	// only merged comments are ever returned from the Tricium service.
	Comments int32 `protobuf:"varint,1,opt,name=comments" json:"comments,omitempty"`
	// Number of collected ‘not useful’ reports.
	NotUsefulReports int32 `protobuf:"varint,2,opt,name=not_useful_reports,json=notUsefulReports" json:"not_useful_reports,omitempty"`
	// List of URLs to ‘not useful’ bug reports.
	Issues []string `protobuf:"bytes,3,rep,name=issues" json:"issues,omitempty"`
}

func (m *FeedbackResponse) Reset()                    { *m = FeedbackResponse{} }
func (m *FeedbackResponse) String() string            { return proto.CompactTextString(m) }
func (*FeedbackResponse) ProtoMessage()               {}
func (*FeedbackResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *FeedbackResponse) GetComments() int32 {
	if m != nil {
		return m.Comments
	}
	return 0
}

func (m *FeedbackResponse) GetNotUsefulReports() int32 {
	if m != nil {
		return m.NotUsefulReports
	}
	return 0
}

func (m *FeedbackResponse) GetIssues() []string {
	if m != nil {
		return m.Issues
	}
	return nil
}

type ReportNotUsefulRequest struct {
	// ID of comment as returned by the Results end point.
	CommentId string `protobuf:"bytes,1,opt,name=comment_id,json=commentId" json:"comment_id,omitempty"`
	// More feedback information.
	//
	// Optional field.
	MoreDetails string `protobuf:"bytes,2,opt,name=more_details,json=moreDetails" json:"more_details,omitempty"`
}

func (m *ReportNotUsefulRequest) Reset()                    { *m = ReportNotUsefulRequest{} }
func (m *ReportNotUsefulRequest) String() string            { return proto.CompactTextString(m) }
func (*ReportNotUsefulRequest) ProtoMessage()               {}
func (*ReportNotUsefulRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

func (m *ReportNotUsefulRequest) GetCommentId() string {
	if m != nil {
		return m.CommentId
	}
	return ""
}

func (m *ReportNotUsefulRequest) GetMoreDetails() string {
	if m != nil {
		return m.MoreDetails
	}
	return ""
}

type ReportNotUsefulResponse struct {
	// URL to issue if created.
	//
	// Only created if there were feedback details.
	Issue string `protobuf:"bytes,1,opt,name=issue" json:"issue,omitempty"`
}

func (m *ReportNotUsefulResponse) Reset()                    { *m = ReportNotUsefulResponse{} }
func (m *ReportNotUsefulResponse) String() string            { return proto.CompactTextString(m) }
func (*ReportNotUsefulResponse) ProtoMessage()               {}
func (*ReportNotUsefulResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

func (m *ReportNotUsefulResponse) GetIssue() string {
	if m != nil {
		return m.Issue
	}
	return ""
}

// Gerrit consumer details to be provided if a Gerrit consumer is specified.
type GerritConsumerDetails struct {
	// Gerrit host.
	//
	// This value must not include protocol and is assumed to not include '##'.
	//
	// This field is required.
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	// Gerrit project name.
	//
	// This value is assumed to not include '##'.
	//
	// This field is required.
	Project string `protobuf:"bytes,2,opt,name=project" json:"project,omitempty"`
	// Gerrit change ID.
	//
	// This value should be a fully qualified ID on the form "<project>~<branch>~<Change-Id>",
	// where <Change-Id> is a SHA and not a lecacy change ID number.
	// Note that refs/heads can be omitted from the branch.
	//
	// Example: "myProject~master~I8473b95934b5732ac55d26311a706c9c2bde9940"
	//
	// This field is required.
	Change string `protobuf:"bytes,3,opt,name=change" json:"change,omitempty"`
	// Gerrit change revision.
	//
	// This value should be the fetch URL for a revision of a change. Note that
	// the last number of a change revision ref maps to the corresponding patch set
	// number.
	//
	// Example: "refs/changes/97/97/1"
	//
	// This field is required.
	Revision string `protobuf:"bytes,4,opt,name=revision" json:"revision,omitempty"`
}

func (m *GerritConsumerDetails) Reset()                    { *m = GerritConsumerDetails{} }
func (m *GerritConsumerDetails) String() string            { return proto.CompactTextString(m) }
func (*GerritConsumerDetails) ProtoMessage()               {}
func (*GerritConsumerDetails) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{11} }

func (m *GerritConsumerDetails) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GerritConsumerDetails) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *GerritConsumerDetails) GetChange() string {
	if m != nil {
		return m.Change
	}
	return ""
}

func (m *GerritConsumerDetails) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func init() {
	proto.RegisterType((*AnalyzeRequest)(nil), "tricium.AnalyzeRequest")
	proto.RegisterType((*AnalyzeResponse)(nil), "tricium.AnalyzeResponse")
	proto.RegisterType((*ProgressRequest)(nil), "tricium.ProgressRequest")
	proto.RegisterType((*ProgressResponse)(nil), "tricium.ProgressResponse")
	proto.RegisterType((*AnalyzerProgress)(nil), "tricium.AnalyzerProgress")
	proto.RegisterType((*ResultsRequest)(nil), "tricium.ResultsRequest")
	proto.RegisterType((*ResultsResponse)(nil), "tricium.ResultsResponse")
	proto.RegisterType((*FeedbackRequest)(nil), "tricium.FeedbackRequest")
	proto.RegisterType((*FeedbackResponse)(nil), "tricium.FeedbackResponse")
	proto.RegisterType((*ReportNotUsefulRequest)(nil), "tricium.ReportNotUsefulRequest")
	proto.RegisterType((*ReportNotUsefulResponse)(nil), "tricium.ReportNotUsefulResponse")
	proto.RegisterType((*GerritConsumerDetails)(nil), "tricium.GerritConsumerDetails")
	proto.RegisterEnum("tricium.State", State_name, State_value)
	proto.RegisterEnum("tricium.Consumer", Consumer_name, Consumer_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Tricium service

type TriciumClient interface {
	// Analyze requests analysis of a list of paths.
	//
	// An analysis request for a list of paths in a project connected to Tricium
	// via the Tricium configuration. On success, the ID of the resulting run is
	// returned.
	Analyze(ctx context.Context, in *AnalyzeRequest, opts ...grpc.CallOption) (*AnalyzeResponse, error)
	// Progress requests progress information for a run.
	//
	// A run corresponds to an analyze request and is identified with a run ID.
	Progress(ctx context.Context, in *ProgressRequest, opts ...grpc.CallOption) (*ProgressResponse, error)
	// Results requests analysis results from a run.
	//
	// A run corresponds to an analyze request and is identified with a run ID.
	Results(ctx context.Context, in *ResultsRequest, opts ...grpc.CallOption) (*ResultsResponse, error)
	// Feedback requests feedback for an analyzer category.
	Feedback(ctx context.Context, in *FeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error)
	// ReportNotUseful reports not useful feedback for a robot comment.
	//
	// NB! Issue reporting is currently not supported.
	ReportNotUseful(ctx context.Context, in *ReportNotUsefulRequest, opts ...grpc.CallOption) (*ReportNotUsefulResponse, error)
}
type triciumPRPCClient struct {
	client *prpc.Client
}

func NewTriciumPRPCClient(client *prpc.Client) TriciumClient {
	return &triciumPRPCClient{client}
}

func (c *triciumPRPCClient) Analyze(ctx context.Context, in *AnalyzeRequest, opts ...grpc.CallOption) (*AnalyzeResponse, error) {
	out := new(AnalyzeResponse)
	err := c.client.Call(ctx, "tricium.Tricium", "Analyze", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumPRPCClient) Progress(ctx context.Context, in *ProgressRequest, opts ...grpc.CallOption) (*ProgressResponse, error) {
	out := new(ProgressResponse)
	err := c.client.Call(ctx, "tricium.Tricium", "Progress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumPRPCClient) Results(ctx context.Context, in *ResultsRequest, opts ...grpc.CallOption) (*ResultsResponse, error) {
	out := new(ResultsResponse)
	err := c.client.Call(ctx, "tricium.Tricium", "Results", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumPRPCClient) Feedback(ctx context.Context, in *FeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error) {
	out := new(FeedbackResponse)
	err := c.client.Call(ctx, "tricium.Tricium", "Feedback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumPRPCClient) ReportNotUseful(ctx context.Context, in *ReportNotUsefulRequest, opts ...grpc.CallOption) (*ReportNotUsefulResponse, error) {
	out := new(ReportNotUsefulResponse)
	err := c.client.Call(ctx, "tricium.Tricium", "ReportNotUseful", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type triciumClient struct {
	cc *grpc.ClientConn
}

func NewTriciumClient(cc *grpc.ClientConn) TriciumClient {
	return &triciumClient{cc}
}

func (c *triciumClient) Analyze(ctx context.Context, in *AnalyzeRequest, opts ...grpc.CallOption) (*AnalyzeResponse, error) {
	out := new(AnalyzeResponse)
	err := grpc.Invoke(ctx, "/tricium.Tricium/Analyze", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumClient) Progress(ctx context.Context, in *ProgressRequest, opts ...grpc.CallOption) (*ProgressResponse, error) {
	out := new(ProgressResponse)
	err := grpc.Invoke(ctx, "/tricium.Tricium/Progress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumClient) Results(ctx context.Context, in *ResultsRequest, opts ...grpc.CallOption) (*ResultsResponse, error) {
	out := new(ResultsResponse)
	err := grpc.Invoke(ctx, "/tricium.Tricium/Results", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumClient) Feedback(ctx context.Context, in *FeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error) {
	out := new(FeedbackResponse)
	err := grpc.Invoke(ctx, "/tricium.Tricium/Feedback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triciumClient) ReportNotUseful(ctx context.Context, in *ReportNotUsefulRequest, opts ...grpc.CallOption) (*ReportNotUsefulResponse, error) {
	out := new(ReportNotUsefulResponse)
	err := grpc.Invoke(ctx, "/tricium.Tricium/ReportNotUseful", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Tricium service

type TriciumServer interface {
	// Analyze requests analysis of a list of paths.
	//
	// An analysis request for a list of paths in a project connected to Tricium
	// via the Tricium configuration. On success, the ID of the resulting run is
	// returned.
	Analyze(context.Context, *AnalyzeRequest) (*AnalyzeResponse, error)
	// Progress requests progress information for a run.
	//
	// A run corresponds to an analyze request and is identified with a run ID.
	Progress(context.Context, *ProgressRequest) (*ProgressResponse, error)
	// Results requests analysis results from a run.
	//
	// A run corresponds to an analyze request and is identified with a run ID.
	Results(context.Context, *ResultsRequest) (*ResultsResponse, error)
	// Feedback requests feedback for an analyzer category.
	Feedback(context.Context, *FeedbackRequest) (*FeedbackResponse, error)
	// ReportNotUseful reports not useful feedback for a robot comment.
	//
	// NB! Issue reporting is currently not supported.
	ReportNotUseful(context.Context, *ReportNotUsefulRequest) (*ReportNotUsefulResponse, error)
}

func RegisterTriciumServer(s prpc.Registrar, srv TriciumServer) {
	s.RegisterService(&_Tricium_serviceDesc, srv)
}

func _Tricium_Analyze_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriciumServer).Analyze(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tricium.Tricium/Analyze",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriciumServer).Analyze(ctx, req.(*AnalyzeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tricium_Progress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriciumServer).Progress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tricium.Tricium/Progress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriciumServer).Progress(ctx, req.(*ProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tricium_Results_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriciumServer).Results(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tricium.Tricium/Results",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriciumServer).Results(ctx, req.(*ResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tricium_Feedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriciumServer).Feedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tricium.Tricium/Feedback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriciumServer).Feedback(ctx, req.(*FeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tricium_ReportNotUseful_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportNotUsefulRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriciumServer).ReportNotUseful(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tricium.Tricium/ReportNotUseful",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriciumServer).ReportNotUseful(ctx, req.(*ReportNotUsefulRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tricium_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tricium.Tricium",
	HandlerType: (*TriciumServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Analyze",
			Handler:    _Tricium_Analyze_Handler,
		},
		{
			MethodName: "Progress",
			Handler:    _Tricium_Progress_Handler,
		},
		{
			MethodName: "Results",
			Handler:    _Tricium_Results_Handler,
		},
		{
			MethodName: "Feedback",
			Handler:    _Tricium_Feedback_Handler,
		},
		{
			MethodName: "ReportNotUseful",
			Handler:    _Tricium_ReportNotUseful_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "infra/tricium/api/v1/tricium.proto",
}

func init() { proto.RegisterFile("infra/tricium/api/v1/tricium.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x0e, 0x2d, 0x53, 0xa2, 0x46, 0x89, 0xcc, 0x2c, 0x62, 0x9b, 0x56, 0x91, 0x46, 0x65, 0x7b,
	0x10, 0x82, 0xd6, 0x46, 0xd5, 0x6b, 0x80, 0xc0, 0x95, 0x68, 0x43, 0x40, 0x42, 0x1b, 0x6b, 0xe9,
	0xd2, 0x0b, 0xb1, 0x11, 0x57, 0x34, 0x6b, 0x91, 0x54, 0x77, 0x97, 0x09, 0xdc, 0x17, 0xe9, 0x63,
	0xf5, 0x09, 0xfa, 0x00, 0x7d, 0x83, 0x1e, 0x0b, 0xee, 0x0f, 0x25, 0xcb, 0x6a, 0x50, 0xa0, 0x87,
	0xde, 0xfc, 0xcd, 0x7c, 0xbb, 0xc3, 0xef, 0xdb, 0x99, 0xb1, 0xc0, 0x4f, 0xf3, 0x05, 0x23, 0x67,
	0x82, 0xa5, 0xf3, 0xb4, 0xcc, 0xce, 0xc8, 0x2a, 0x3d, 0xfb, 0xf8, 0xbd, 0x81, 0xa7, 0x2b, 0x56,
	0x88, 0x02, 0xb5, 0x34, 0xec, 0xbd, 0xda, 0x49, 0x8e, 0x89, 0x20, 0x8a, 0xd9, 0xfb, 0x7a, 0x27,
	0x61, 0xb5, 0x24, 0x62, 0x51, 0x30, 0x7d, 0x9d, 0xff, 0xbb, 0x05, 0xdd, 0xf3, 0x9c, 0x2c, 0xef,
	0x7f, 0xa5, 0x98, 0xfe, 0x52, 0x52, 0x2e, 0x90, 0x07, 0xad, 0x15, 0x2b, 0x7e, 0xa6, 0x73, 0xe1,
	0x59, 0x7d, 0x6b, 0xd0, 0xc6, 0x06, 0xa2, 0x63, 0x68, 0x25, 0xa9, 0x88, 0x18, 0x5d, 0x78, 0x7b,
	0x32, 0xd3, 0x4c, 0x52, 0x81, 0xe9, 0x02, 0xbd, 0x00, 0x7b, 0x45, 0xc4, 0x2d, 0xf7, 0x1a, 0xfd,
	0xc6, 0xa0, 0x8d, 0x15, 0x40, 0xdf, 0x81, 0x33, 0x2f, 0x72, 0x5e, 0x66, 0x94, 0x79, 0xfb, 0x7d,
	0x6b, 0xd0, 0x1d, 0x3e, 0x3f, 0x35, 0x62, 0x46, 0x3a, 0x81, 0x6b, 0x0a, 0x0a, 0xa0, 0x9b, 0x50,
	0xc6, 0x52, 0x11, 0xc5, 0x54, 0x90, 0x74, 0xc9, 0x3d, 0xbb, 0x6f, 0x0d, 0x3a, 0xc3, 0x2f, 0xeb,
	0x43, 0x97, 0x32, 0x6d, 0x8e, 0x8e, 0x15, 0x0b, 0x3f, 0x53, 0xa7, 0x34, 0xf4, 0x07, 0x70, 0x50,
	0x0b, 0xe2, 0xab, 0x22, 0xe7, 0x14, 0x1d, 0x42, 0x93, 0x95, 0x79, 0x94, 0xc6, 0x5a, 0x90, 0xcd,
	0xca, 0x7c, 0x12, 0xfb, 0x7f, 0x5a, 0x70, 0x70, 0xcd, 0x8a, 0x84, 0x51, 0xce, 0x8d, 0xf8, 0xdd,
	0x54, 0xd4, 0x03, 0x87, 0xa8, 0x4b, 0x99, 0x96, 0x5e, 0xe3, 0x4a, 0xa6, 0x31, 0xd5, 0x6b, 0xc8,
	0x2f, 0x5e, 0xcb, 0xbc, 0xd6, 0x09, 0x5c, 0x53, 0xfe, 0x27, 0x57, 0x7e, 0xb3, 0xc0, 0x5d, 0x6b,
	0xfd, 0xac, 0x2f, 0xe8, 0x1b, 0xb0, 0xb9, 0x20, 0x82, 0x4a, 0xa5, 0xdd, 0x61, 0xb7, 0xae, 0x74,
	0x53, 0x45, 0xb1, 0x4a, 0xa2, 0x0b, 0x78, 0x6e, 0x2c, 0x88, 0x56, 0xfa, 0x66, 0xf9, 0xfe, 0x9d,
	0xe1, 0x49, 0x7d, 0x42, 0xbf, 0x04, 0xab, 0x4b, 0xbb, 0x64, 0x2b, 0xe2, 0xff, 0x65, 0x81, 0xbb,
	0x4d, 0x7b, 0xe0, 0xb7, 0xb5, 0xe5, 0xf7, 0x70, 0xc3, 0x6f, 0xf5, 0x85, 0x47, 0x8f, 0xfc, 0x3e,
	0x0d, 0x49, 0x46, 0x37, 0x4c, 0xaf, 0x25, 0x35, 0x3e, 0x27, 0xe9, 0x2b, 0x78, 0xca, 0x3f, 0x11,
	0x96, 0xa5, 0x79, 0x12, 0x95, 0x6c, 0x29, 0x9f, 0xa7, 0x8d, 0x3b, 0x26, 0x36, 0x63, 0x4b, 0x34,
	0x00, 0xb7, 0xa6, 0x08, 0xc2, 0xef, 0x2a, 0xf3, 0x6c, 0x49, 0xeb, 0x9a, 0xf8, 0x94, 0xf0, 0xbb,
	0x49, 0x5c, 0x5d, 0x96, 0x97, 0x59, 0x34, 0x2f, 0xb2, 0x8c, 0xe6, 0x82, 0x7b, 0xcd, 0xbe, 0x35,
	0xb0, 0x71, 0x27, 0x2f, 0xb3, 0x91, 0x0e, 0xf9, 0x9f, 0xa0, 0x8b, 0x29, 0x2f, 0x97, 0xe2, 0xbf,
	0xb4, 0xdf, 0x70, 0xab, 0xfd, 0xfe, 0x85, 0x1d, 0x7e, 0x04, 0x07, 0x75, 0x61, 0xdd, 0x0b, 0x67,
	0xd0, 0x62, 0x2a, 0x24, 0x4b, 0x77, 0x86, 0x87, 0xf5, 0x2d, 0xe3, 0x6a, 0xa7, 0x18, 0xbe, 0x61,
	0xa1, 0x2f, 0xa0, 0x9d, 0xf2, 0x28, 0xa3, 0x2c, 0xa1, 0xb1, 0xfc, 0x28, 0x07, 0x3b, 0x29, 0x7f,
	0x2f, 0xb1, 0x9f, 0xc0, 0xc1, 0x05, 0xa5, 0xf1, 0x07, 0x32, 0xbf, 0x33, 0xd2, 0x7a, 0xe0, 0xcc,
	0x89, 0xa0, 0x49, 0xc1, 0xee, 0xcd, 0x93, 0x1a, 0x8c, 0x5e, 0x02, 0x70, 0x41, 0x98, 0x88, 0x44,
	0x9a, 0x51, 0xad, 0xb0, 0x2d, 0x23, 0xd3, 0x34, 0xa3, 0xe8, 0x04, 0x1c, 0x9a, 0xc7, 0x2a, 0xd9,
	0x50, 0x2b, 0x89, 0xe6, 0x71, 0x95, 0xf2, 0x05, 0xb8, 0xeb, 0x42, 0x5a, 0x4a, 0x55, 0xc9, 0xb8,
	0x6e, 0x49, 0xd7, 0x6b, 0x8c, 0xbe, 0x05, 0x94, 0x17, 0x22, 0x2a, 0x39, 0x5d, 0x94, 0xcb, 0x88,
	0xd1, 0x55, 0xc1, 0x04, 0x97, 0x15, 0x6d, 0xec, 0xe6, 0x85, 0x98, 0xc9, 0x04, 0x56, 0x71, 0x74,
	0x04, 0xcd, 0x94, 0xf3, 0x92, 0x9a, 0xc5, 0xa6, 0x91, 0xff, 0x13, 0x1c, 0x29, 0x4a, 0xb8, 0x3e,
	0xa1, 0x54, 0xbe, 0x04, 0xd0, 0xb5, 0xd6, 0x8f, 0xd8, 0xd6, 0x11, 0xd5, 0x14, 0x59, 0xc1, 0x68,
	0x3d, 0xcb, 0x4a, 0x6a, 0xa7, 0x8a, 0x99, 0x49, 0x3d, 0x83, 0xe3, 0x47, 0x77, 0x6b, 0x61, 0x2f,
	0xc0, 0x96, 0x1f, 0x60, 0x9a, 0x43, 0x02, 0xff, 0x1e, 0x0e, 0x77, 0xae, 0x00, 0x84, 0x60, 0xff,
	0xb6, 0xe0, 0x66, 0x8b, 0xcb, 0xbf, 0x37, 0x97, 0xfb, 0xde, 0xc3, 0xe5, 0x7e, 0x04, 0xcd, 0xf9,
	0x2d, 0xc9, 0x13, 0x63, 0xb1, 0x46, 0x95, 0x9b, 0x8c, 0x7e, 0x4c, 0x79, 0x5a, 0xe4, 0x7a, 0x20,
	0x6a, 0xfc, 0x9a, 0x82, 0x2d, 0x07, 0x08, 0x75, 0xa0, 0x75, 0x1d, 0x84, 0xe3, 0x49, 0x78, 0xe9,
	0x3e, 0xa9, 0x00, 0x9e, 0x85, 0x61, 0x05, 0xac, 0x0a, 0xdc, 0xcc, 0x46, 0xa3, 0xe0, 0xe6, 0xc6,
	0xdd, 0xab, 0xc0, 0xc5, 0xf9, 0xe4, 0xdd, 0x0c, 0x07, 0x6e, 0x03, 0x3d, 0x05, 0x67, 0x74, 0x1e,
	0x8e, 0x82, 0x77, 0xc1, 0xd8, 0xdd, 0x47, 0xcf, 0xa0, 0x3d, 0x9d, 0xbc, 0x0f, 0xc6, 0xd1, 0xd5,
	0x6c, 0xea, 0xda, 0x15, 0xf3, 0xfc, 0xc7, 0x2b, 0x3c, 0x0d, 0xc6, 0x6e, 0xf3, 0x75, 0x1f, 0x1c,
	0xa3, 0x0d, 0x39, 0xb0, 0x1f, 0x5e, 0x85, 0x81, 0xfb, 0x04, 0x01, 0x34, 0x2f, 0x03, 0x8c, 0x27,
	0x53, 0xd7, 0x1a, 0xfe, 0xb1, 0x07, 0xad, 0xa9, 0x6a, 0x57, 0xf4, 0x06, 0x5a, 0x7a, 0x9f, 0xa0,
	0xe3, 0xed, 0x45, 0xa4, 0x9f, 0xa9, 0xe7, 0x3d, 0x4e, 0x68, 0x8f, 0xdf, 0x82, 0x53, 0x6f, 0xa1,
	0x35, 0x6b, 0xeb, 0xdf, 0x44, 0xef, 0x64, 0x47, 0x46, 0x5f, 0xf0, 0x06, 0x5a, 0x7a, 0x56, 0x36,
	0xca, 0x3f, 0x1c, 0xf3, 0x8d, 0xf2, 0xdb, 0x63, 0xf8, 0x16, 0x1c, 0xd3, 0xcf, 0x1b, 0xe5, 0xb7,
	0x66, 0x69, 0xa3, 0xfc, 0xa3, 0xe6, 0x9f, 0x56, 0xa3, 0xfd, 0xa0, 0x7d, 0xd0, 0xab, 0x8d, 0x6a,
	0xbb, 0x9a, 0xb6, 0xd7, 0xff, 0x67, 0x82, 0xba, 0xf5, 0x43, 0x53, 0xfe, 0x5a, 0xf8, 0xe1, 0xef,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x52, 0x26, 0x9f, 0x05, 0xa2, 0x08, 0x00, 0x00,
}
