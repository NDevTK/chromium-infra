<link rel="import" href="../../bower_components/polymer-redux/polymer-redux.html">
<script src="../../node_modules/redux/dist/redux.js"></script>
<script>
  (function(window) {
    // Assumption: We don't want to display multiple dialogs at once.
    const DialogState = Object.freeze({
      NONE: 0,
      EDIT_ISSUE: 1,

      // TODO(zhangtiff): Move other dialogs to be managed by Redux. (or not?)
      EDIT_APPROVAL: 2,
      VIEW_ATTACHMENT: 3,
    });

    const actionType = {
      // Misc global state.
      UPDATE_ISSUE_REF: 'UPDATE_ISSUE_REF',
      UPDATE_TOKEN: 'UPDATE_TOKEN',
      UPDATE_USER: 'UPDATE_USER',

      // UI state.
      OPEN_DIALOG: 'OPEN_DIALOG',
      CLOSE_DIALOG: 'CLOSE_DIALOG',

      // AJAX request state.
      FETCH_ISSUE_START: 'FETCH_ISSUE_START',
      FETCH_ISSUE_SUCCESS: 'FETCH_ISSUE_SUCCESS',
      FETCH_ISSUE_FAILURE: 'FETCH_ISSUE_FAILURE',

      STAR_ISSUE_START: 'STAR_ISSUE_START',
      STAR_ISSUE_SUCCESS: 'STAR_ISSUE_SUCCESS',
      STAR_ISSUE_FAILURE: 'STAR_ISSUE_FAILURE',

      FETCH_IS_STARRED_START: 'FETCH_IS_STARRED_START',
      FETCH_IS_STARRED_SUCCESS: 'FETCH_IS_STARRED_SUCCESS',
      FETCH_IS_STARRED_FAILURE: 'FETCH_IS_STARRED_FAILURE',

      FETCH_COMMENTS_START: 'FETCH_COMMENTS_START',
      FETCH_COMMENTS_SUCCESS: 'FETCH_COMMENTS_SUCCESS',
      FETCH_COMMENTS_FAILURE: 'FETCH_COMMENTS_FAILURE',

      UPDATE_ISSUE_START: 'UPDATE_ISSUE_START',
      UPDATE_ISSUE_SUCCESS: 'UPDATE_ISSUE_SUCCESS',
      UPDATE_ISSUE_FAILURE: 'UPDATE_ISSUE_FAILURE',

      UPDATE_APPROVAL_START: 'UPDATE_APPROVAL_START',
      UPDATE_APPROVAL_SUCCESS: 'UPDATE_APPROVAL_SUCCESS',
      UPDATE_APPROVAL_FAILURE: 'UPDATE_APPROVAL_FAILURE',
    };

    const actionCreator = {
      fetchComments: (dispatch, message) => {
        dispatch({type: actionType.FETCH_COMMENTS_START});

        const getComments = window.prpcClient.call(
          'monorail.Issues', 'ListComments', message
        );

        getComments.then((resp) => {
          dispatch({
            type: actionType.FETCH_COMMENTS_SUCCESS,
            comments: resp.comments,
          });
        }, (error) => {
          this.dispatch({
            type: actionType.FETCH_COMMENTS_FAILURE,
            error,
          });
        });
      },
      fetchIsStarred: (dispatch, message) => {
        dispatch({type: actionType.FETCH_IS_STARRED_START});

        const getIsStarred = window.prpcClient.call(
          'monorail.Issues', 'IsIssueStarred', message
        );

        getIsStarred.then((resp) => {
          dispatch({
            type: actionType.FETCH_IS_STARRED_SUCCESS,
            isStarred: resp.isStarred,
          });
        }, (error) => {
          dispatch({
            type: actionType.FETCH_IS_STARRED_FAILURE,
            error,
          });
        });
      },
    };

    const initial = {
      issueId: 0,
      projectName: '',
      issue: {},
      comments: [],
      isStarred: false,
      token: null,

      openedDialog: DialogState.NONE,

      issueLoaded: false,
      fetchingIssue: false,
      fetchIssueError: null,

      fetchingComments: false,
      fetchCommentsError: null,

      starringIssue: false,
      starIssueError: null,

      fetchingIsStarred: false,
      fetchIsStarredError: null,

      updatingIssue: false,
      updateIssueError: null,

      // Assumption: It's okay to prevent the user from sending multiple
      // approval update requests at once, even for different approvals.
      updatingApproval: false,
      updateApprovalError: null,
    };

    // Helpers for the reducers.
    const updateIssueApproval = (issue, approval) => {
      if (!issue.approvalValues) return issue;
      const newApprovals = issue.approvalValues.map((item, i) => {
        if (item.fieldRef.fieldName === approval.fieldRef.fieldName) {
          // PhaseRef isn't populated on the response so we want to make sure
          // it doesn't overwrite the original phaseRef with {}.
          const a = Object.assign({}, approval, {phaseRef: item.phaseRef});
          return a;
        }
        return item;
      });
      return Object.assign({}, issue, {approvalValues: newApprovals});
    }

    const reducer = (state, action) => {
      switch (action.type) {
        case actionType.UPDATE_ISSUE_REF:
          return Object.assign({}, state, {
            issueId: action.issueId || state.issueId,
            projectName: action.projectName || state.projectName,
          });
        case actionType.UPDATE_TOKEN:
          return Object.assign({}, state, {
            token: action.token,
          });
        case actionType.UPDATE_USER:
          return Object.assign({}, state, {
            user: action.user,
          });

        // Opening and closing dialogs.
        case actionType.OPEN_DIALOG:
          return Object.assign({}, state, {
            openedDialog: action.dialog,
          });
        case actionType.CLOSE_DIALOG:
          return Object.assign({}, state, {
            openedDialog: DialogState.NONE,
          });

        // Request for getting an issue.
        case actionType.FETCH_ISSUE_START:
          return Object.assign({}, state, {
            issue: {},
            comments: [],
            issueLoaded: false,
            fetchIssueError: null,
            fetchingIssue: true,
          });
        case actionType.FETCH_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: action.issue,
            issueLoaded: true,
            fetchingIssue: false,
          });
        case actionType.FETCH_ISSUE_FAILURE:
          return Object.assign({}, state, {
            fetchIssueError: action.error,
            fetchingIssue: false,
          });

        // Request for starring an issue.
        case actionType.STAR_ISSUE_START:
          return Object.assign({}, state, {
            starIssueError: null,
            starringIssue: true,
          });
        case actionType.STAR_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: Object.assign({}, state.issue, {starCount: action.starCount}),
            isStarred: action.isStarred,
            starringIssue: false,
          });
        case actionType.STAR_ISSUE_FAILURE:
          return Object.assign({}, state, {
            starIssueError: action.error,
            starringIssue: false,
          });

        // Request for getting comments for an issue.
        case actionType.FETCH_COMMENTS_START:
          return Object.assign({}, state, {
            fetchCommentsError: null,
            fetchingComments: true,
          });
        case actionType.FETCH_COMMENTS_SUCCESS:
          return Object.assign({}, state, {
            comments: action.comments,
            fetchingComments: false,
          });
        case actionType.FETCH_COMMENTS_FAILURE:
          return Object.assign({}, state, {
            fetchCommentsError: action.error,
            fetchingComments: false,
          });

        // Request for getting whether an issue is starred.
        case actionType.FETCH_IS_STARRED_START:
          return Object.assign({}, state, {
            fetchIsStarredError: null,
            fetchingIsStarred: true,
          });
        case actionType.FETCH_IS_STARRED_SUCCESS:
          return Object.assign({}, state, {
            isStarred: action.isStarred,
            fetchingIsStarred: false,
          });
        case actionType.FETCH_IS_STARRED_FAILURE:
          return Object.assign({}, state, {
            fetchIsStarredError: action.error,
            fetchingIsStarred: false,
          });

        // Request for updating an issue.
        case actionType.UPDATE_ISSUE_START:
          return Object.assign({}, state, {
            updatingIssue: true,
          });
        case actionType.UPDATE_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: action.issue,
            updatingIssue: false,
          });
        case actionType.UPDATE_ISSUE_FAILURE:
          return Object.assign({}, state, {
            updateIssueError: action.error,
            updatingIssue: false,
          });

        // Request for updating an approval.
        case actionType.UPDATE_APPROVAL_START:
          return Object.assign({}, state, {
            updatingApproval: true,
          });
        case actionType.UPDATE_APPROVAL_SUCCESS:
          return Object.assign({}, state, {
            issue: updateIssueApproval(state.issue, action.approval),
            updatingApproval: false,
          });
        case actionType.UPDATE_APPROVAL_FAILURE:
          return Object.assign({}, state, {
            updateApprovalError: action.error,
            updatingApproval: false,
          });

        default:
          return state;
      }
    };
    const store = Redux.createStore(reducer, initial);

    ReduxMixin = PolymerRedux(store);

    window.ReduxMixin = ReduxMixin || {};
    window.store = store || {};
    window.actionType = actionType || {};
    window.actionCreator = actionCreator || {};
    window.DialogState = DialogState || {};
  })(window);
</script>
