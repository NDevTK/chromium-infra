<!DOCTYPE html>
<meta charset="utf-8">
<script src="/bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<script src="../tsmon-client.js"></script>
<test-fixture id="basic">
</test-fixture>
<script>
(function() {
  'use strict';
  const TSMonClient = window.chops.tsmon.TSMonClient;
  const ValueType = window.chops.tsmon.ValueType;
  const FieldType = window.chops.tsmon.FieldType;

  let tsm;

  setup(function() {
    tsm = new TSMonClient();
    tsm._name = 'testname';
    tsm._jobName = 'testJobName';
    sinon.stub(window, 'fetch');
    let res = new window.Response('Ok.', {
      status: 200,
      headers: {
        'Content-type': 'application/json',
      },
    });
    window.fetch.returns(Promise.resolve(res));
  });

  teardown(function() {
    window.fetch.restore();
  });

  function assertLowerBounds(b, expected) {
    const expectedTotal = expected.length;

    chai.assert.equal(expectedTotal - 2, b.numFiniteBuckets);
    chai.assert.equal(expectedTotal, b.totalBuckets);
    chai.assert.equal(0, b.underflowBucket);
    chai.assert.equal(expectedTotal - 1, b.overflowBucket);
    chai.assert.deepEqual(expected, b._lowerBounds);

    expected.forEach((lowerBound, i) => {
      if (i > expected.length - 2) {
        return;
      }
      const upperBound = expected[i + 1];

      chai.assert.isTrue(lowerBound < upperBound);
      chai.assert.deepEqual([lowerBound, upperBound], b.bucketBoundaries(i));
      chai.assert.equal(i, b.bucketForValue(lowerBound));
      chai.assert.equal(i, b.bucketForValue(lowerBound + 0.5));
      chai.assert.equal(i, b.bucketForValue(upperBound - 0.5));

      chai.assert.throws(function() {
        b.bucketBoundaries(-1);
      });
      chai.assert.throws(() => {
        b.bucketBoundaries(expected.length);
      });
    });
  }

  function assertMapEqual(a ,b) {
    chai.assert.equal(a.size, b.size, 'map sizes');
    for (const [k, v] of a) {
      chai.assert.isTrue(b.has(k), 'other map has key ' + k);
      if (v instanceof Map) {
        assertMapEqual(v, b.get(k));
      } else {
        chai.assert.equal(v, b.get(k), 'value for key ' + k);
      }
    }
  }

  suite('fixed width bucketer', function() {
    test('equaltiy', function() {
      const b = TSMonClient.fixedWidthBucketer(10, 8);
      chai.assert.equal(b, b)
    });

    test('negative size', function() {
      chai.assert.throws(function() {
        TSMonClient.fixedWidthBucketer(10, -1);
      }, Error);
    });

    test('negative width', function() {
      chai.assert.throws(function() {
        TSMonClient.fixedWidthBucketer(-1, 1);
      }, Error);
    });

    test('zero size', function() {
      const b = TSMonClient.fixedWidthBucketer(10, 0);
      assertLowerBounds(b, [-Infinity, 0]);
    });

    test('one size', function() {
      const b = TSMonClient.fixedWidthBucketer(10, 1);
      assertLowerBounds(b, [-Infinity, 0, 10]);
    });

    test('bucket for value', function() {
      const b = TSMonClient.fixedWidthBucketer(10, 5);
      chai.assert.equal(0, b.bucketForValue(-Infinity));
      chai.assert.equal(0, b.bucketForValue(-100));
      chai.assert.equal(0, b.bucketForValue(-1));
      chai.assert.equal(1, b.bucketForValue(0));
      chai.assert.equal(5, b.bucketForValue(45));
      chai.assert.equal(6, b.bucketForValue(51));
      chai.assert.equal(6, b.bucketForValue(100000));
      chai.assert.equal(6, b.bucketForValue(Infinity));
    });
  });

  suite('geometric bucketer', function() {
    test('equaltiy', function() {
      const b = TSMonClient.geometricBucketer(4, 4, 0.1);
      chai.assert.equal(b, b);
    });

    test('negative size', function() {
      chai.assert.throws(function() {
        TSMonClient.geometricBucketer(0, -1);
      }, Error);
    });

    test('bad growth factors', function() {
      chai.assert.throws(function() {
        TSMonClient.geometricBucketer(-1);
      }, Error);
      chai.assert.throws(function() {
        TSMonClient.geometricBucketer(1);
      }, Error);
    });

    test('zero size', function() {
      const b = TSMonClient.geometricBucketer(0, 0);
      assertLowerBounds(b, [-Infinity, 1]);
    });

    test('large size', function() {
      const b = TSMonClient.geometricBucketer(4, 4);
      assertLowerBounds(b, [-Infinity, 1, 4, 16, 64, 256]);
    });

    test('scale', function() {
      const b = TSMonClient.geometricBucketer(4, 4, 0.1);
      chai.assert.equal(0, b.bucketForValue(-Infinity));
      chai.assert.equal(0, b.bucketForValue(0.05));
      chai.assert.equal(1, b.bucketForValue(0.2));
      chai.assert.equal(5, b.bucketForValue(Infinity));
    });

    test('bucket for value', function() {
      const b = TSMonClient.geometricBucketer(2, 5);
      chai.assert.equal(0, b.bucketForValue(-Infinity));
      chai.assert.equal(0, b.bucketForValue(-100));
      chai.assert.equal(0, b.bucketForValue(-1));
      chai.assert.equal(0, b.bucketForValue(0));
      chai.assert.equal(1, b.bucketForValue(1));
      chai.assert.equal(5, b.bucketForValue(31));
      chai.assert.equal(6, b.bucketForValue(32));
      chai.assert.equal(6, b.bucketForValue(100000));
      chai.assert.equal(6, b.bucketForValue(Infinity));

    });
  });

  suite('distribution', function() {
    test('add', function() {
      const d = new chops.tsmon.Distribution(TSMonClient.geometricBucketer());
      chai.assert.equal(0, d.sum);
      chai.assert.equal(0, d.count);
      chai.assert.deepEqual(new Map(), d.buckets);

      d.add(1);
      d.add(10);
      d.add(100);

      chai.assert.equal(111, d.sum);
      chai.assert.equal(3, d.count);
      assertMapEqual(new Map([[1, 1], [5, 1], [10, 1]]), d.buckets);

      d.add(50);

      chai.assert.equal(161, d.sum);
      chai.assert.equal(4, d.count);
      chai.assert.deepEqual(new Map([[1, 1], [5, 1], [9, 1], [10, 1]]), d.buckets);
    });

    test('add on bucket boundary', function() {
      const d = new chops.tsmon.Distribution(TSMonClient.fixedWidthBucketer(10));
      d.add(10);

      chai.assert.equal(10, d.sum);
      chai.assert.equal(1, d.count);
      chai.assert.deepEqual(new Map([[1, 1], [2, 1]]), d.buckets);
    });

    test('underflow bucket', function() {
      const d = new chops.tsmon.Distribution(TSMonClient.fixedWidthBucketer(10));
      d.add(-1);

      chai.assert.equal(-1, d.sum);
      chai.assert.equal(1, d.count);
      chai.assert.deepEqual(new Map([[0, 1]]), d.buckets);

      d.add(-1000000);
      chai.assert.equal(-1000001, d.sum);
      chai.assert.equal(2, d.count);
      chai.assert.deepEqual(new Map([[0, 2]]), d.buckets);
    });

    test('overflow bucket', function() {
      const d = new chops.tsmon.Distribution(TSMonClient.fixedWidthBucketer(10, 10));
      d.add(100);

      chai.assert.equal(100, d.sum);
      chai.assert.equal(1, d.count);
      chai.assert.deepEqual(new Map([[11, 1]]), d.buckets);

      d.add(1000000);
      chai.assert.equal(1000100, d.sum);
      chai.assert.equal(2, d.count);
      chai.assert.deepEqual(new Map([[11, 2]]), d.buckets);
    });
  });

  suite('flush', function() {
   test('disableAfterNextFlush stops sending metrics', function() {
     chai.assert.isTrue(tsm._continueSendingMetrics);
     chai.assert.isOk(tsm._flushTimer);

      tsm.disableAfterNextFlush();
      tsm._onFlush();

      chai.assert.isFalse(tsm._continueSendingMetrics);
      chai.assert.isNull(tsm._flushTimer);
      chai.assert.isTrue(window.fetch.called);
    });

    test('cumulative distribution', function() {
      let fields = new Map(Object.entries({
        "foo_field": TSMonClient.stringField('foo_field'),
      }));
      let c = tsm.cumulativeDistribution('frontend/cumulativedistribution_test',
          'cumulative distribution test', undefined, fields);
      let ts = 1;
      tsm.now = () => { return ts; }

      fields = new Map(Object.entries({"foo_field": "bar_value"}));
      c.add(1, fields);
      tsm.flush();

      // First call immediately flushes.
      sinon.assert.calledWith(window.fetch,
        sinon.match(tsm._reportPath), sinon.match({
          method: 'POST',
          credentials: 'same-origin',
          body: JSON.stringify({
            "metrics":[{
              "MetricInfo": {
                "Name": c.info.Name,
                "Desription": c.info.Description,
                "Fields": {
                  "foo_field": {
                    "Name": "foo_field",
                    "Type": FieldType.STRING,
                  }
                },
                "ValueType": c.info.ValueType,
              },
              "Cells": [{
                "value": {
                  "sum": 1,
                  "count": 1,
                  "buckets": [[1,1]],
                },
                "fields": {
                  "foo_field": "bar_value"
                },
                "start_time": tsm._initTimeSeconds,
              }]
            }],
            "token": null,
          }),
        }
      ));

      ts = 2;
      const firstTimestamp = ts;
      c.add(2, fields);
      c.add(2, fields);
      ts = 3;
      c.add(5, fields);
      c.add(5, fields);
      c.add(5, fields);
      c.add(10, fields);

      tsm.flush();
      sinon.assert.calledWith(window.fetch,
        sinon.match(tsm._reportPath), sinon.match({
          method: 'POST',
          credentials: 'same-origin',
          body: JSON.stringify({
            "metrics":[{
              "MetricInfo": {
                "Name": c.info.Name,
                "Desription": c.info.Description,
                "Fields": {
                  "foo_field": {
                    "Name": "foo_field",
                    "Type": FieldType.STRING,
                  }
                },
                "ValueType": c.info.ValueType,
              },
              "Cells": [{
                "value": {
                  "sum": 29,
                  "count": 6,
                  "buckets": [[2, 2], [4, 3], [5, 1]]
                },
                "fields": {
                  "foo_field": "bar_value"
                },
                "start_time": tsm._initTimeSeconds,
              }]
            }],
            "token": null,
          }),
        }
      ));
    });
  });
})();
</script>
