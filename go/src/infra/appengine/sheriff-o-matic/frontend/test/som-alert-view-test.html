<!DOCTYPE html>
<meta charset="utf-8">
<script src="/bower_components/webcomponentsjs/webcomponents.min.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="/bower_components/iron-test-helpers/iron-test-helpers.html">
<link rel="import" href="/elements/som-alert-view/som-alert-view.html">
<test-fixture id="basic">
  <template>
    <som-alert-view></som-alert-view>
  </template>
</test-fixture>
<script>
(function() {
  'use strict';
  var element;
  var server;
  var responseHeaders = {
      json: {'Content-Type': 'application/json'},
      text: {'Content-Type': 'text/html'},
  };

  setup(function() {
    element = fixture('basic');
    sinon.stub(window, 'fetch');
  });

  teardown(function() {
    window.fetch.restore();
  });

  suite('basic tests', function() {
    test('alerts not found', function(done) {
      let tree = 'notfound';
      let groups = [tree];

      let res = new window.Response(null, {
        status: 404,
        headers: {
          'Content-type': 'application/json',
        }
      });

      window.fetch.returns(Promise.resolve(res));

      element._updateAlerts(groups);

      assert.isTrue(window.fetch.calledOnce);

      flush(function() {
        assert.notEqual(element._fetchAlertsError, '');
        expect(element.$.fetchAlertsError).be.visible;
        done();
      });
    });
  });

  suite('categories', function() {
    test('renders severity groups', function(done) {
      element.set(['_alertsData', 'test'], [{
          'key': 'something',
          'severity': 2,
      }]);

      flush(function() {
        assert.equal(
            element.$$('.category-title-text').textContent.trim(),
            element._getCategoryTitle(2) + ' (1 total)');
        done();
      });
    });

    test('renders tree groups for troopers', function(done) {
      window.fetch.returns(Promise.resolve());
      element.tree = {'name': 'trooper'};
      element.set(['_alertsData', 'test'], [{
          'key': 'something',
          'severity': 2,
          'tree': 'test',
      }]);

      flush(function() {
        assert.equal(
            element.$$('.category-title-text').textContent.trim(),
              'test infra failures (1 total)');
        done();
      });
    });
  });

  suite('alert streams', function() {
    var clock;

    setup(function() {
      clock = sinon.useFakeTimers();
    });

    test('merge multiple alert streams', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}], reasons: [ {step: 'a'} ]},
            key: 'test key' },
        ],
        other: [
          {extension: { builders: [{name: 'blahblah'}], reasons: [ {step: 'reasons'} ]} },
        ],
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test key': {
          snoozeTime: Date.now() + 1000000,
        }
      });

      assert.equal(2, sortedAlerts.length);
      assert.equal('blahblah', sortedAlerts[0].extension.builders[0].name);
      // a is snoozed, goes to the bottom.
      assert.equal('a', sortedAlerts[1].extension.builders[0].name);
    });

    test('merge multiple alert streams with one null', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}], reasons: [ {step: 'a'} ]},
            key: 'test key' },
        ],
        other: null
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test key': {
          snoozeTime: Date.now() + 1000000,
        }
      });

      assert.equal(1, sortedAlerts.length);
      assert.equal('a', sortedAlerts[0].extension.builders[0].name);
    });

    test('ignores requests sent from stale trees', function(done) {
      let oldRes = new window.Response('{"alerts": ["oldtreealert"]}', {
        status: 200,
        headers: {
          'Content-type': 'application/json',
        }
      });
      let resolveOldPromise;
      let oldPromise = new Promise((resolve, reject) => {
        resolveOldPromise = resolve;
      });

      let newRes = new window.Response('{"alerts": ["newtreealert"]}', {
        status: 200,
        headers: {
          'Content-type': 'application/json',
        }
      });
      let resolveNewPromise;
      let newPromise = new Promise((resolve, reject) => {
        resolveNewPromise = resolve;
      });

      window.fetch.returns(oldPromise);
      element.tree = {'name': 'oldtree'};
      assert.deepEqual(element._alertStreams, ['oldtree']);
      assert.isTrue(window.fetch.calledOnce);

      window.fetch.returns(newPromise);
      element.tree = {'name': 'newtree'};
      assert.deepEqual(element._alertStreams, ['newtree']);
      assert.isTrue(window.fetch.calledTwice);

      resolveNewPromise(newRes);
      flush(() => {
        assert.deepEqual(element._alertsData, {'newtree': ['newtreealert']});

        resolveOldPromise(oldRes);
        flush(() => {
          assert.deepEqual(element._alertsData, {'newtree': ['newtreealert']});
          done();
        });
      });
    });

    test('sort works correctly', function() {
      let alertsData = {
        test: [
          {extension: { builders: [{name: 'a'}, {name: 'b'}, {name: 'z'}], reasons: [ {step: 'a'} ]},
            title: 'a'},
          {extension: { builders: [{name: 'c'}], reasons: [ {step: 'a'} ]},
            title: 'b'},
          {extension: { builders: [{name: 'd'}], reasons: [ {step: 'c'} ]}, title: 'd' },
          {extension: { builders: [{name: 'e'}], reasons: [ {step: 'd'} ]}, title: 'e' },
          {extension: { builders: [{name: 'f'}], reasons: [ {step: 'b'} ]},
            key: 'hello', title: 'd'},
          {extension: { builders: [{name: 'g'}], reasons: [ {step: 'a'} ]},
            key: 'test', title: 'c'},
          {extension: { builders: [{name: 'h'}], reasons: [ {step: 'a'} ], suspected_cls: [{revision: '1'}]},
           title: 'h'},
          {extension: { builders: [{name: 'i'}], reasons: [ {step: 'a'} ], suspected_cls: [{revision: 'rev2', reverting_cl_url: 'revert_url'}]},
           title: 'i'},
          {extension: { builders: [{name: 'j'}], reasons: [ {step: 'a'} ], has_findings: true},
           title: 'j'},
        ]
      };

      let sortedAlerts = element._computeAlerts({
        base: alertsData
      }, {
        'test': {
          snoozeTime: Date.now() + 1000000,
        },
        'hello': {
          bugs: ['test'],
        },
      });


      let names = sortedAlerts.map((alr) => {
        return alr.extension.builders[0].name;
      })
      assert.deepEqual(names, ['i', 'h', 'j', 'a', 'c', 'd', 'e', 'f', 'g']);
      // b has a bug so it goes between c/d (no annotations) and a (snoozed).
      // a is snoozed, goes to the bottom.
    });
  });

  suite('refresh', function() {
    var refreshStub;
    var clock;

    setup(function() {
      refreshStub = sinon.stub(element, 'refresh');
      clock = sinon.useFakeTimers();
    });

    test('refreshes after a period', function(done) {
      element.created();
      clock.tick(60 * 1000);
      flush(function() {
        sinon.assert.calledOnce(refreshStub);
        done();
      });
    });
  });
})();
</script>
