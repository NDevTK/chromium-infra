<meta charset="utf-8">
<script src="/bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="/elements/shared/field-types.html">
<link rel="import" href="/elements/flt/mr-edit-metadata/mr-edit-field.html">
<test-fixture id="basic">
  <template>
    <mr-edit-field></mr-edit-field>
  </template>
</test-fixture>
<script>
(function() {
  'use strict';

  suite('single input', function() {
    let element;

    setup(function() {
      element = fixture('basic');
    });

    test('input updates when initialValues change', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        assert.equal(element.getValue(), 'hello');
        done();
      });
    });

    test('initial value does not change after setValue', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        element.setValue('world');
        assert.deepEqual(element.initialValues, ['hello']);
        done();
      });
    });

    test('input updates when setValue is called', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        element.setValue('world');
        assert.equal(element.getValue(), 'world');
        done();
      });
    });

    test('initial value does not change after user input', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#editInput').value = 'jackalope';
        assert.deepEqual(element.initialValues, ['hello']);
        done();
      });
    });

    test('get value after user input', function(done) {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#editInput').value = 'jackalope';
        assert.equal(element.getValue(), 'jackalope');
        done();
    });

    test('input value was added', function(done) {
      flush(() => {
        // Simulate user input.
        element.shadowRoot.querySelector('#editInput').value = 'jackalope';
        assert.deepEqual(element.getValuesAdded(), ['jackalope']);
        done();
      });
    });

    test('input value was removed', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#editInput').value = '';
        assert.deepEqual(element.getValuesRemoved(), ['hello']);
        done();
      });
    });

    test('input value was changed', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#editInput').value = 'world';
        assert.deepEqual(element.getValuesAdded(), ['world']);
        done();
      });
    });
  });

  suite('multiple input', function() {
    let element;

    setup(function() {
      element = fixture('basic');
      element.multi = true;
    });

    test('input updates when initialValues change', function(done) {
      flush(() => {
        element.initialValues = ['hello', 'world'];
        assert.deepEqual(element.getValues(), ['hello', 'world']);
        done();
      });
    });

    test('initial value does not change after setValue', function(done) {
      flush(() => {
        element.initialValues = ['hello', 'world'];
        element.setValue(['jaunty', 'jackalope']);
        assert.deepEqual(element.initialValues, ['hello', 'world']);
        done();
      });
    });

    test('input updates when setValue is called', function(done) {
      flush(() => {
        element.initialValues = ['hello', 'world'];
        element.setValue(['jaunty', 'jackalope']);
        assert.deepEqual(element.getValues(), ['jaunty', 'jackalope']);
        done();
      });
    });

    test('initial value does not change after user input', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#multi1').value = 'heron';
        assert.deepEqual(element.initialValues, ['hello']);
        done();
      });
    });

    test('get value after user input', function(done) {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#multi1').value = 'heron';
        assert.deepEqual(element.getValues(), ['hello', 'heron']);
        done();
    });

    test('input value was added', function(done) {
      flush(() => {
        // Simulate user input.
        element.shadowRoot.querySelector('#multi0').value = 'jackalope';
        assert.deepEqual(element.getValuesAdded(), ['jackalope']);
        done();
      });
    });

    test('input value was removed', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#multi0').value = '';
        assert.deepEqual(element.getValuesRemoved(), ['hello']);
        done();
      });
    });

    test('input value was changed', function(done) {
      flush(() => {
        element.initialValues = ['hello'];
        // Simulate user input.
        element.shadowRoot.querySelector('#multi0').value = 'world';
        assert.deepEqual(element.getValuesAdded(), ['world']);
        assert.deepEqual(element.getValuesRemoved(), ['hello']);
        done();
      });
    });
  });

  suite('other', function() {
    let element;

    setup(function() {
      element = fixture('basic');
    });

    test('edit select updates value when initialValues change', function(done) {
      element.multi = false;
      element.type = fieldTypes.ENUM_TYPE;

      element.options = [
        {optionName: 'hello'},
        {optionName: 'jackalope'},
        {optionName: 'text'},
      ];

      flush(() => {
        element.initialValues = ['hello'];
        assert.equal(element.getValue(), 'hello');

        // Simulate user input.
        element.shadowRoot.querySelector('#editSelect').value = 'jackalope';
        // User input should not be overridden by the initialValue variable.
        assert.equal(element.getValue(), 'jackalope');
        // Initial values should not change based on user input.
        assert.deepEqual(element.initialValues, ['hello']);

        element.initialValues = ['text'];
        assert.equal(element.getValue(), 'text');
        done();
      });
    });

    test('edit enum updates value when initialValues change', function(done) {
      element.multi = true;
      element.type = fieldTypes.ENUM_TYPE;
      element.options = [
        {optionName: 'hello'},
        {optionName: 'world'},
        {optionName: 'fake'},
      ];

      flush(() => {
        element.initialValues = ['hello'];
        assert.deepEqual(element.getValues(), ['hello']);

        // User checks all boxes.
        element.shadowRoot.querySelectorAll('.enum-input').forEach(
          (checkbox) => {
            checkbox.checked = true;
          }
        );
        // User input should not be overridden by the initialValue variable.
        assert.deepEqual(element.getValues(), ['hello', 'world', 'fake']);
        // Initial values should not change based on user input.
        assert.deepEqual(element.initialValues, ['hello']);

        element.initialValues = ['hello', 'world'];
        assert.deepEqual(element.getValues(), ['hello', 'world']);
        done();
      });
    });
  });
})();
</script>
