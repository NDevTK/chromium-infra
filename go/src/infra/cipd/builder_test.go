// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package cipd

import (
	"archive/zip"
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	_ "crypto/sha1"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"io"
	"io/ioutil"
	"os"
	"runtime"
	"testing"

	. "github.com/smartystreets/goconvey/convey"
)

// TODO: Add tests that read back and validate the signature block once code
// to read it is added (no need to implement it twice, for tests and for real).

func TestPrivateKeyWorks(t *testing.T) {
	Convey("Make sure bundled test private key can be loaded", t, func() {
		k := privateKey()
		So(k, ShouldNotBeNil)
		So(k.Validate(), ShouldBeNil)
	})
}

func TestGoVersion(t *testing.T) {
	Convey("Make sure using pinned Go version", t, func() {
		// Change this when rolling pinned Go version. Some tests here may depend
		// on zlib implementation details compiled in Go stdlib.
		So(runtime.Version(), ShouldEqual, "go1.3.3")
	})
}

func TestBuildPackage(t *testing.T) {
	const goodManifest = `{
  "FormatVersion": "1",
  "PackageName": "testing"
}`

	Convey("Building empty package", t, func() {
		out := bytes.Buffer{}
		err := BuildPackage(BuildPackageOptions{
			Input:       []File{},
			Output:      &out,
			PackageName: "testing",
		})
		So(err, ShouldBeNil)

		// BuildPackage builds deterministic zip. It MUST NOT depend on
		// the platform, or a time of day, or anything else, only on the input data.
		So(sha1(&out), ShouldEqual, "4571652804acba0ec97c37c2257d6ac67c87baa1")

		// There should be a single file: the manifest.
		files := readZip(out.Bytes())
		So(files, ShouldResemble, []zippedFile{
			zippedFile{
				// See structs.go, manifestName.
				name: ".cipdpkg/manifest.json",
				size: 54,
				mode: 0600,
				body: []byte(goodManifest),
			},
		})
	})

	Convey("Building package with a bunch of files", t, func() {
		out := bytes.Buffer{}
		err := BuildPackage(BuildPackageOptions{
			Input: []File{
				makeTestFile("testing/qwerty", "12345", false),
				makeTestFile("abc", "duh", true),
			},
			Output:      &out,
			PackageName: "testing",
		})
		So(err, ShouldBeNil)

		// The manifest and all added files.
		files := readZip(out.Bytes())
		So(files, ShouldResemble, []zippedFile{
			zippedFile{
				name: "testing/qwerty",
				size: 5,
				mode: 0600,
				body: []byte("12345"),
			},
			zippedFile{
				name: "abc",
				size: 3,
				mode: 0700,
				body: []byte("duh"),
			},
			zippedFile{
				// See structs.go, manifestName.
				name: ".cipdpkg/manifest.json",
				size: 54,
				mode: 0600,
				body: []byte(goodManifest),
			},
		})
	})

	Convey("Duplicate files fail", t, func() {
		err := BuildPackage(BuildPackageOptions{
			Input: []File{
				makeTestFile("a", "12345", false),
				makeTestFile("a", "12345", false),
			},
			Output:      &bytes.Buffer{},
			PackageName: "testing",
		})
		So(err, ShouldNotBeNil)
	})

	Convey("Writing to service dir fails", t, func() {
		err := BuildPackage(BuildPackageOptions{
			Input: []File{
				makeTestFile(".cipdpkg/stuff", "12345", false),
			},
			Output:      &bytes.Buffer{},
			PackageName: "testing",
		})
		So(err, ShouldNotBeNil)
	})
}

func TestSignPackage(t *testing.T) {
	// Just code coverage ensuring it's not panicing. More tests will be added
	// later when the code to read package is added.
	Convey("Signing works", t, func() {
		out := bytes.Buffer{}
		err := BuildPackage(BuildPackageOptions{
			Input:       []File{},
			Output:      &out,
			PackageName: "testing",
		})
		So(err, ShouldBeNil)

		err = SignPackage(SignPackageOptions{
			Package:    bytes.NewReader(out.Bytes()),
			Output:     &bytes.Buffer{},
			PrivateKey: privateKey(),
			Random:     rand.Reader,
		})
		So(err, ShouldBeNil)
	})
}

////////////////////////////////////////////////////////////////////////////////

// 1024bit RSA private key, just for testing.
// Generated by 'openssl genrsa -out private.pem 1024'
var pkey = `-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQDNUJYDD/cLzIpCbEHyCRWCWaYajI5thLviKDHJoBjjQZdzGy/k
lIGYTTDyXCC8XNtmDBfZaV1gMj5SZAtNMbarvWyUtek++pE8ZoOhyO/sy6P652Fb
stcZn+UbO6x8JFI12mjUHn9vLzeo90cFpedP60WZqyK025thWaZJO3LghQIDAQAB
AoGBAMPajM9tClhaDMXiKWIuYjNPO5F15WP5y5SojR3uN++JoWRvWdduBtX3RKrd
UWj+F1iYTqPZy/Y415SW1OUVeE9SPo7yw21Y893Lxioahzeo2TMg+5dqskJ0T6OX
lSsgCwM02q/r3g3rJjIqC6hJPRtUXUlrlbgsgFJCKikmC4ZdAkEA/SC6W5sZVUMz
LS43K1H76K5UGeOEC2FwrU2xnCkpkgh+wH3Eql8UeK1PngjercYO9OcwzYt1K+mp
EpsUJ2dwEwJBAM+k+Sc2OnZq4aX6tg2NrvmZzJ031aeXi2WGviHoTK6fvmHrRSbU
12fVB7+yk6CjDy/mQAtQUXHmfdqRivrf8AcCQQDHmW0aGx1IzGqob871C/rWKdEL
cQqIZteQ8Lji6Nps2uIIK6ROrBbaad9kQJ5G7OySVVN4YUWN0PyPPVYRFFGdAkEA
jDjLLIi5aDh7U1wATxzL+bC79bu746Y6M4CPq1Q1XINxzKxVkYiQQoUg63qLqSIU
YnNp8nn11iYh/VTl9s79RwJAaiWtkA5HoiO53RKVTCmO/te1F9TzBvda7z2jGiqF
KcrJ5HlhilaBDv4VcFjbI20V82ZrymlWgjAUq0xoixNIdg==
-----END RSA PRIVATE KEY-----`

// privateKey() returns RSA private key to use in tests.
func privateKey() *rsa.PrivateKey {
	block, rest := pem.Decode([]byte(pkey))
	if len(rest) != 0 {
		panic("PEM should have one block only")
	}
	if block.Type != "RSA PRIVATE KEY" {
		panic("Expecting RSA PRIVATE KEY")
	}
	key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		panic("Failed to parse RSA key")
	}
	return key
}

// sha1 returns SHA1 hex digest of a byte buffer.
func sha1(buf *bytes.Buffer) string {
	h := crypto.SHA1.New()
	h.Write(buf.Bytes())
	return hex.EncodeToString(h.Sum(nil))
}

////////////////////////////////////////////////////////////////////////////////

type zippedFile struct {
	name string
	size uint64
	mode os.FileMode
	body []byte
}

// readZip scans zip directory and returns files it finds.
func readZip(data []byte) []zippedFile {
	z, err := zip.NewReader(bytes.NewReader(data), int64(len(data)))
	if err != nil {
		panic("Failed to open zip file")
	}
	files := make([]zippedFile, len(z.File))
	for i, zf := range z.File {
		reader, err := zf.Open()
		if err != nil {
			panic("Failed to open file inside zip")
		}
		body, err := ioutil.ReadAll(reader)
		if err != nil {
			panic("Failed to read zipped file")
		}
		files[i] = zippedFile{
			name: zf.Name,
			size: zf.FileHeader.UncompressedSize64,
			mode: zf.Mode(),
			body: body,
		}
	}
	return files
}

////////////////////////////////////////////////////////////////////////////////

type testFile struct {
	name       string
	data       string
	executable bool
}

func (f *testFile) Name() string     { return f.name }
func (f *testFile) Size() uint64     { return uint64(len(f.data)) }
func (f *testFile) Executable() bool { return f.executable }
func (f *testFile) Open() (io.ReadCloser, error) {
	r := bytes.NewReader([]byte(f.data))
	return ioutil.NopCloser(r), nil
}

func makeTestFile(name string, data string, executable bool) File {
	return &testFile{
		name:       name,
		data:       data,
		executable: executable,
	}
}
