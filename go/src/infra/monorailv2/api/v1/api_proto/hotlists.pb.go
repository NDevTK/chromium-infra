// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/v1/api_proto/hotlists.proto

package monorail_v1

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The request used to update a Hotlist.
// Next available tag: 2
type UpdateHotlistRequest struct {
	// The hotlist's `name` field is used to identify the hotlist to be updated.
	Hotlist *Hotlist `protobuf:"bytes,1,opt,name=hotlist,proto3" json:"hotlist,omitempty"`
	// The list of fields to be updated.
	UpdateMask           *field_mask.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UpdateHotlistRequest) Reset()         { *m = UpdateHotlistRequest{} }
func (m *UpdateHotlistRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateHotlistRequest) ProtoMessage()    {}
func (*UpdateHotlistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56a2c4cb0040a55a, []int{0}
}

func (m *UpdateHotlistRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateHotlistRequest.Unmarshal(m, b)
}
func (m *UpdateHotlistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateHotlistRequest.Marshal(b, m, deterministic)
}
func (m *UpdateHotlistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateHotlistRequest.Merge(m, src)
}
func (m *UpdateHotlistRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateHotlistRequest.Size(m)
}
func (m *UpdateHotlistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateHotlistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateHotlistRequest proto.InternalMessageInfo

func (m *UpdateHotlistRequest) GetHotlist() *Hotlist {
	if m != nil {
		return m.Hotlist
	}
	return nil
}

func (m *UpdateHotlistRequest) GetUpdateMask() *field_mask.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// The request used to rerank a Hotlist.
// Next available tag: 4
type RerankHotlistItemsRequest struct {
	// Resource name of the Hotlist to rerank.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// HotlistItems to be moved. The order of `hotlist_items` will
	// determine the order of these items after they have been moved.
	// E.g. With items [a, b, c, d, e], moving [d, c] to `target_position` 3, will
	// result in items [a, b, e, d, c].
	HotlistItems []string `protobuf:"bytes,2,rep,name=hotlist_items,json=hotlistItems,proto3" json:"hotlist_items,omitempty"`
	// Target starting position of the moved items.
	// `target_position` must be between 0 and (# hotlist items - # items being moved).
	TargetPosition       uint32   `protobuf:"varint,3,opt,name=target_position,json=targetPosition,proto3" json:"target_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RerankHotlistItemsRequest) Reset()         { *m = RerankHotlistItemsRequest{} }
func (m *RerankHotlistItemsRequest) String() string { return proto.CompactTextString(m) }
func (*RerankHotlistItemsRequest) ProtoMessage()    {}
func (*RerankHotlistItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_56a2c4cb0040a55a, []int{1}
}

func (m *RerankHotlistItemsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RerankHotlistItemsRequest.Unmarshal(m, b)
}
func (m *RerankHotlistItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RerankHotlistItemsRequest.Marshal(b, m, deterministic)
}
func (m *RerankHotlistItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RerankHotlistItemsRequest.Merge(m, src)
}
func (m *RerankHotlistItemsRequest) XXX_Size() int {
	return xxx_messageInfo_RerankHotlistItemsRequest.Size(m)
}
func (m *RerankHotlistItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RerankHotlistItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RerankHotlistItemsRequest proto.InternalMessageInfo

func (m *RerankHotlistItemsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RerankHotlistItemsRequest) GetHotlistItems() []string {
	if m != nil {
		return m.HotlistItems
	}
	return nil
}

func (m *RerankHotlistItemsRequest) GetTargetPosition() uint32 {
	if m != nil {
		return m.TargetPosition
	}
	return 0
}

func init() {
	proto.RegisterType((*UpdateHotlistRequest)(nil), "monorail.v1.UpdateHotlistRequest")
	proto.RegisterType((*RerankHotlistItemsRequest)(nil), "monorail.v1.RerankHotlistItemsRequest")
}

func init() { proto.RegisterFile("api/v1/api_proto/hotlists.proto", fileDescriptor_56a2c4cb0040a55a) }

var fileDescriptor_56a2c4cb0040a55a = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xc1, 0x6e, 0xd3, 0x30,
	0x1c, 0xc6, 0xe5, 0x14, 0x01, 0x73, 0x29, 0x48, 0xd6, 0x80, 0x2e, 0x13, 0xa2, 0xcb, 0xa1, 0x2a,
	0xd3, 0x66, 0xab, 0xdd, 0x05, 0xed, 0x44, 0x2b, 0x31, 0xc1, 0x61, 0x12, 0xaa, 0xc4, 0x39, 0x72,
	0xb2, 0x7f, 0x5b, 0xd3, 0x26, 0x36, 0xb6, 0x53, 0x89, 0x03, 0x17, 0x1e, 0x80, 0x0b, 0x37, 0x5e,
	0x80, 0x17, 0xe1, 0x0d, 0x78, 0x81, 0x1d, 0x78, 0x0a, 0x4e, 0x28, 0x8e, 0x23, 0xad, 0x34, 0x65,
	0x47, 0xe7, 0xff, 0xfb, 0x7f, 0xdf, 0xe7, 0xcf, 0xc1, 0xcf, 0xb9, 0x12, 0x6c, 0x3d, 0x64, 0x5c,
	0x89, 0x58, 0x69, 0x69, 0x25, 0x5b, 0x48, 0xbb, 0x12, 0xc6, 0x1a, 0xea, 0x8e, 0xa4, 0x9d, 0xc9,
	0x5c, 0x6a, 0x2e, 0x56, 0x74, 0x3d, 0x0c, 0xfb, 0x5b, 0xf4, 0x0c, 0xb8, 0x2d, 0x34, 0xc4, 0x32,
	0xf9, 0x00, 0x69, 0xbd, 0x14, 0xf6, 0xe6, 0x52, 0xce, 0x57, 0xc0, 0xdc, 0x29, 0x29, 0x66, 0x6c,
	0x26, 0x60, 0x75, 0x15, 0x67, 0xdc, 0x2c, 0x3d, 0x71, 0xf8, 0x2f, 0x01, 0x99, 0xb2, 0x9f, 0xfc,
	0xf0, 0xa4, 0x1a, 0x7a, 0x0b, 0x4f, 0x96, 0xd6, 0x95, 0x4c, 0x02, 0x0b, 0xbe, 0x16, 0x52, 0x7b,
	0xba, 0xbf, 0x8b, 0xd6, 0x60, 0x64, 0xa1, 0x53, 0xf0, 0xdc, 0x8b, 0x5d, 0x1c, 0xcf, 0x73, 0x69,
	0xb9, 0x15, 0x32, 0xf7, 0xf9, 0xa3, 0x1f, 0x08, 0xef, 0xbf, 0x57, 0x57, 0xdc, 0xc2, 0x9b, 0xaa,
	0x8d, 0x29, 0x7c, 0x2c, 0xc0, 0x58, 0x72, 0x89, 0xef, 0xf9, 0x7e, 0xba, 0xa8, 0x87, 0x06, 0xed,
	0xd1, 0x3e, 0xbd, 0xd1, 0x0f, 0xf5, 0xf4, 0xe4, 0xd9, 0xf5, 0x38, 0xf8, 0x33, 0x7e, 0x8a, 0x1f,
	0x73, 0x25, 0x68, 0xaa, 0x93, 0x62, 0x4e, 0x53, 0x99, 0xb1, 0x5a, 0xac, 0xd6, 0x20, 0xaf, 0x70,
	0xbb, 0x70, 0x36, 0xae, 0x9a, 0x6e, 0xe0, 0x24, 0x43, 0x5a, 0x65, 0xa3, 0x75, 0x37, 0xf4, 0xa2,
	0xbc, 0xf6, 0x25, 0x37, 0xcb, 0x49, 0xeb, 0x7a, 0x1c, 0x4c, 0x71, 0xb5, 0x53, 0x7e, 0x88, 0x7e,
	0x22, 0x7c, 0x30, 0x05, 0xcd, 0xf3, 0xa5, 0x17, 0x7f, 0x6b, 0x21, 0x33, 0x75, 0xdc, 0x21, 0xbe,
	0x93, 0xf3, 0x0c, 0x5c, 0xd6, 0xbd, 0xdb, 0x52, 0x39, 0x94, 0x5c, 0xe0, 0x8e, 0x4f, 0x17, 0x8b,
	0x52, 0xaa, 0x1b, 0xf4, 0x5a, 0x83, 0xbd, 0xc9, 0x91, 0xdb, 0x3d, 0xc4, 0x07, 0x8d, 0xbb, 0xa5,
	0xe9, 0xf4, 0xc1, 0xe2, 0x46, 0x02, 0x72, 0x82, 0x1f, 0x59, 0xae, 0xe7, 0x60, 0x63, 0x25, 0x8d,
	0x28, 0xcb, 0xed, 0xb6, 0x7a, 0x68, 0xd0, 0xa9, 0xae, 0xf0, 0xb0, 0x9a, 0xbd, 0xf3, 0xa3, 0xd1,
	0xf7, 0x00, 0xdf, 0xf7, 0x5a, 0x86, 0x7c, 0xc6, 0x9d, 0x8d, 0xf2, 0xc9, 0xd1, 0x46, 0xc9, 0x4d,
	0x0f, 0x13, 0x36, 0xbe, 0x43, 0x74, 0xf6, 0xe5, 0xd7, 0xef, 0x6f, 0xc1, 0x69, 0x34, 0x60, 0x4a,
	0xab, 0x94, 0x35, 0x20, 0x86, 0x6d, 0xc8, 0x9d, 0xa3, 0x63, 0xf2, 0x15, 0x61, 0xb2, 0x5d, 0x29,
	0xe9, 0x6f, 0x38, 0xec, 0xec, 0x3c, 0x7c, 0xb2, 0xf5, 0x7c, 0xaf, 0xcb, 0x5f, 0x3b, 0x7a, 0xe9,
	0xb2, 0x8c, 0xa2, 0xd3, 0xff, 0x64, 0xd9, 0x56, 0x3d, 0x47, 0xc7, 0xc9, 0x5d, 0xa7, 0x74, 0xf6,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x34, 0x2c, 0xc0, 0xac, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HotlistsClient is the client API for Hotlists service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HotlistsClient interface {
	// Updates a hotlist.
	// TODO(monorail:6988): Document possible errors when implemented.
	UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error)
	// Reranks a hotlist's items.
	//
	// Raises:
	//   NOT_FOUND if the hotlist to rerank is not found.
	//   PERMISSION_DENIED if the requester is not allowed to rerank the hotlist.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}
type hotlistsPRPCClient struct {
	client *prpc.Client
}

func NewHotlistsPRPCClient(client *prpc.Client) HotlistsClient {
	return &hotlistsPRPCClient{client}
}

func (c *hotlistsPRPCClient) UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.client.Call(ctx, "monorail.v1.Hotlists", "UpdateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v1.Hotlists", "RerankHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type hotlistsClient struct {
	cc *grpc.ClientConn
}

func NewHotlistsClient(cc *grpc.ClientConn) HotlistsClient {
	return &hotlistsClient{cc}
}

func (c *hotlistsClient) UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.cc.Invoke(ctx, "/monorail.v1.Hotlists/UpdateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v1.Hotlists/RerankHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HotlistsServer is the server API for Hotlists service.
type HotlistsServer interface {
	// Updates a hotlist.
	// TODO(monorail:6988): Document possible errors when implemented.
	UpdateHotlist(context.Context, *UpdateHotlistRequest) (*Hotlist, error)
	// Reranks a hotlist's items.
	//
	// Raises:
	//   NOT_FOUND if the hotlist to rerank is not found.
	//   PERMISSION_DENIED if the requester is not allowed to rerank the hotlist.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RerankHotlistItems(context.Context, *RerankHotlistItemsRequest) (*empty.Empty, error)
}

// UnimplementedHotlistsServer can be embedded to have forward compatible implementations.
type UnimplementedHotlistsServer struct {
}

func (*UnimplementedHotlistsServer) UpdateHotlist(ctx context.Context, req *UpdateHotlistRequest) (*Hotlist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHotlist not implemented")
}
func (*UnimplementedHotlistsServer) RerankHotlistItems(ctx context.Context, req *RerankHotlistItemsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RerankHotlistItems not implemented")
}

func RegisterHotlistsServer(s prpc.Registrar, srv HotlistsServer) {
	s.RegisterService(&_Hotlists_serviceDesc, srv)
}

func _Hotlists_UpdateHotlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHotlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).UpdateHotlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v1.Hotlists/UpdateHotlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).UpdateHotlist(ctx, req.(*UpdateHotlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_RerankHotlistItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankHotlistItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).RerankHotlistItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v1.Hotlists/RerankHotlistItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).RerankHotlistItems(ctx, req.(*RerankHotlistItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Hotlists_serviceDesc = grpc.ServiceDesc{
	ServiceName: "monorail.v1.Hotlists",
	HandlerType: (*HotlistsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateHotlist",
			Handler:    _Hotlists_UpdateHotlist_Handler,
		},
		{
			MethodName: "RerankHotlistItems",
			Handler:    _Hotlists_RerankHotlistItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/api_proto/hotlists.proto",
}
