// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/v3/api_proto/hotlists.proto

package monorail_v3

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request message for CreateHotlist method.
// Next available tag: 2
type CreateHotlistRequest struct {
	// The hotlist to create.
	// `hotlist.owner` must be empty. The owner of the new hotlist will be
	// set to the requester.
	Hotlist              *Hotlist `protobuf:"bytes,1,opt,name=hotlist,proto3" json:"hotlist,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateHotlistRequest) Reset()         { *m = CreateHotlistRequest{} }
func (m *CreateHotlistRequest) String() string { return proto.CompactTextString(m) }
func (*CreateHotlistRequest) ProtoMessage()    {}
func (*CreateHotlistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{0}
}

func (m *CreateHotlistRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateHotlistRequest.Unmarshal(m, b)
}
func (m *CreateHotlistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateHotlistRequest.Marshal(b, m, deterministic)
}
func (m *CreateHotlistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateHotlistRequest.Merge(m, src)
}
func (m *CreateHotlistRequest) XXX_Size() int {
	return xxx_messageInfo_CreateHotlistRequest.Size(m)
}
func (m *CreateHotlistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateHotlistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateHotlistRequest proto.InternalMessageInfo

func (m *CreateHotlistRequest) GetHotlist() *Hotlist {
	if m != nil {
		return m.Hotlist
	}
	return nil
}

// Request message for GetHotlist method.
// Next available tag: 2
type GetHotlistRequest struct {
	// The name of the hotlist to retrieve.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHotlistRequest) Reset()         { *m = GetHotlistRequest{} }
func (m *GetHotlistRequest) String() string { return proto.CompactTextString(m) }
func (*GetHotlistRequest) ProtoMessage()    {}
func (*GetHotlistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{1}
}

func (m *GetHotlistRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetHotlistRequest.Unmarshal(m, b)
}
func (m *GetHotlistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetHotlistRequest.Marshal(b, m, deterministic)
}
func (m *GetHotlistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHotlistRequest.Merge(m, src)
}
func (m *GetHotlistRequest) XXX_Size() int {
	return xxx_messageInfo_GetHotlistRequest.Size(m)
}
func (m *GetHotlistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHotlistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetHotlistRequest proto.InternalMessageInfo

func (m *GetHotlistRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request message for UpdateHotlist method.
// Next available tag: 2
type UpdateHotlistRequest struct {
	// The hotlist's `name` field is used to identify the hotlist to be updated.
	Hotlist *Hotlist `protobuf:"bytes,1,opt,name=hotlist,proto3" json:"hotlist,omitempty"`
	// The list of fields to be updated.
	UpdateMask           *field_mask.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UpdateHotlistRequest) Reset()         { *m = UpdateHotlistRequest{} }
func (m *UpdateHotlistRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateHotlistRequest) ProtoMessage()    {}
func (*UpdateHotlistRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{2}
}

func (m *UpdateHotlistRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateHotlistRequest.Unmarshal(m, b)
}
func (m *UpdateHotlistRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateHotlistRequest.Marshal(b, m, deterministic)
}
func (m *UpdateHotlistRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateHotlistRequest.Merge(m, src)
}
func (m *UpdateHotlistRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateHotlistRequest.Size(m)
}
func (m *UpdateHotlistRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateHotlistRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateHotlistRequest proto.InternalMessageInfo

func (m *UpdateHotlistRequest) GetHotlist() *Hotlist {
	if m != nil {
		return m.Hotlist
	}
	return nil
}

func (m *UpdateHotlistRequest) GetUpdateMask() *field_mask.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// Request message for ListHotlistItems method.
// Next available tag: 5
type ListHotlistItemsRequest struct {
	// The parent hotlist, which owns this collection of items.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of items to return. The service may return fewer than
	// this value.
	// If unspecified, at most 1000 items will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The string of comma separated field names used to order the items.
	// Adding '-' before a field, reverses the sort order.
	// E.g. 'stars,-status' sorts the items by number of stars low to high, then
	// status high to low.
	// If unspecified, items will be ordered by their rank in the parent.
	OrderBy string `protobuf:"bytes,3,opt,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// A page token, received from a previous `ListHotlistItems` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `ListHotlistItems` must
	// match the call that provided the page token.
	PageToken            string   `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListHotlistItemsRequest) Reset()         { *m = ListHotlistItemsRequest{} }
func (m *ListHotlistItemsRequest) String() string { return proto.CompactTextString(m) }
func (*ListHotlistItemsRequest) ProtoMessage()    {}
func (*ListHotlistItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{3}
}

func (m *ListHotlistItemsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListHotlistItemsRequest.Unmarshal(m, b)
}
func (m *ListHotlistItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListHotlistItemsRequest.Marshal(b, m, deterministic)
}
func (m *ListHotlistItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHotlistItemsRequest.Merge(m, src)
}
func (m *ListHotlistItemsRequest) XXX_Size() int {
	return xxx_messageInfo_ListHotlistItemsRequest.Size(m)
}
func (m *ListHotlistItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHotlistItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHotlistItemsRequest proto.InternalMessageInfo

func (m *ListHotlistItemsRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListHotlistItemsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListHotlistItemsRequest) GetOrderBy() string {
	if m != nil {
		return m.OrderBy
	}
	return ""
}

func (m *ListHotlistItemsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Response to ListHotlistItems call.
// Next available tag: 3
type ListHotlistItemsResponse struct {
	// The items from the specified hotlist.
	Items []*HotlistItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListHotlistItemsResponse) Reset()         { *m = ListHotlistItemsResponse{} }
func (m *ListHotlistItemsResponse) String() string { return proto.CompactTextString(m) }
func (*ListHotlistItemsResponse) ProtoMessage()    {}
func (*ListHotlistItemsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{4}
}

func (m *ListHotlistItemsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListHotlistItemsResponse.Unmarshal(m, b)
}
func (m *ListHotlistItemsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListHotlistItemsResponse.Marshal(b, m, deterministic)
}
func (m *ListHotlistItemsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHotlistItemsResponse.Merge(m, src)
}
func (m *ListHotlistItemsResponse) XXX_Size() int {
	return xxx_messageInfo_ListHotlistItemsResponse.Size(m)
}
func (m *ListHotlistItemsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHotlistItemsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListHotlistItemsResponse proto.InternalMessageInfo

func (m *ListHotlistItemsResponse) GetItems() []*HotlistItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ListHotlistItemsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The request used to rerank a Hotlist.
// Next available tag: 4
type RerankHotlistItemsRequest struct {
	// Resource name of the Hotlist to rerank.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// HotlistItems to be moved. The order of `hotlist_items` will
	// determine the order of these items after they have been moved.
	// E.g. With items [a, b, c, d, e], moving [d, c] to `target_position` 3, will
	// result in items [a, b, e, d, c].
	HotlistItems []string `protobuf:"bytes,2,rep,name=hotlist_items,json=hotlistItems,proto3" json:"hotlist_items,omitempty"`
	// Target starting position of the moved items.
	// `target_position` must be between 0 and (# hotlist items - # items being moved).
	TargetPosition       uint32   `protobuf:"varint,3,opt,name=target_position,json=targetPosition,proto3" json:"target_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RerankHotlistItemsRequest) Reset()         { *m = RerankHotlistItemsRequest{} }
func (m *RerankHotlistItemsRequest) String() string { return proto.CompactTextString(m) }
func (*RerankHotlistItemsRequest) ProtoMessage()    {}
func (*RerankHotlistItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{5}
}

func (m *RerankHotlistItemsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RerankHotlistItemsRequest.Unmarshal(m, b)
}
func (m *RerankHotlistItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RerankHotlistItemsRequest.Marshal(b, m, deterministic)
}
func (m *RerankHotlistItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RerankHotlistItemsRequest.Merge(m, src)
}
func (m *RerankHotlistItemsRequest) XXX_Size() int {
	return xxx_messageInfo_RerankHotlistItemsRequest.Size(m)
}
func (m *RerankHotlistItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RerankHotlistItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RerankHotlistItemsRequest proto.InternalMessageInfo

func (m *RerankHotlistItemsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RerankHotlistItemsRequest) GetHotlistItems() []string {
	if m != nil {
		return m.HotlistItems
	}
	return nil
}

func (m *RerankHotlistItemsRequest) GetTargetPosition() uint32 {
	if m != nil {
		return m.TargetPosition
	}
	return 0
}

// Request message for an AddHotlistItems call.
// Next available tag: 4
type AddHotlistItemsRequest struct {
	// Resource name of the Hotlist to add new items to.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Resource names of Issues to associate with new HotlistItems added to `parent`.
	Issues []string `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// Target starting position of the new items.
	// `target_position` must be between [0 and # of items that currently exist in
	// `parent`]. The request will fail if a specified `target_position` is outside
	// of this range.
	// New HotlistItems added to a non-last position of the hotlist will
	// cause ranks of existing HotlistItems below `target_position` to be adjusted.
	// If no `target_position` is given, new items will be added to the end of
	// `parent`.
	TargetPosition       uint32   `protobuf:"varint,3,opt,name=target_position,json=targetPosition,proto3" json:"target_position,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddHotlistItemsRequest) Reset()         { *m = AddHotlistItemsRequest{} }
func (m *AddHotlistItemsRequest) String() string { return proto.CompactTextString(m) }
func (*AddHotlistItemsRequest) ProtoMessage()    {}
func (*AddHotlistItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{6}
}

func (m *AddHotlistItemsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddHotlistItemsRequest.Unmarshal(m, b)
}
func (m *AddHotlistItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddHotlistItemsRequest.Marshal(b, m, deterministic)
}
func (m *AddHotlistItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddHotlistItemsRequest.Merge(m, src)
}
func (m *AddHotlistItemsRequest) XXX_Size() int {
	return xxx_messageInfo_AddHotlistItemsRequest.Size(m)
}
func (m *AddHotlistItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddHotlistItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddHotlistItemsRequest proto.InternalMessageInfo

func (m *AddHotlistItemsRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *AddHotlistItemsRequest) GetIssues() []string {
	if m != nil {
		return m.Issues
	}
	return nil
}

func (m *AddHotlistItemsRequest) GetTargetPosition() uint32 {
	if m != nil {
		return m.TargetPosition
	}
	return 0
}

// Request message for a RemoveHotlistItems call.
// Next available tag: 3
type RemoveHotlistItemsRequest struct {
	// Resource name of the Hotlist to remove items from.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Resource names of Issues associated with HotlistItems that should be removed.
	Issues               []string `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveHotlistItemsRequest) Reset()         { *m = RemoveHotlistItemsRequest{} }
func (m *RemoveHotlistItemsRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveHotlistItemsRequest) ProtoMessage()    {}
func (*RemoveHotlistItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{7}
}

func (m *RemoveHotlistItemsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveHotlistItemsRequest.Unmarshal(m, b)
}
func (m *RemoveHotlistItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveHotlistItemsRequest.Marshal(b, m, deterministic)
}
func (m *RemoveHotlistItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveHotlistItemsRequest.Merge(m, src)
}
func (m *RemoveHotlistItemsRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveHotlistItemsRequest.Size(m)
}
func (m *RemoveHotlistItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveHotlistItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveHotlistItemsRequest proto.InternalMessageInfo

func (m *RemoveHotlistItemsRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *RemoveHotlistItemsRequest) GetIssues() []string {
	if m != nil {
		return m.Issues
	}
	return nil
}

// Request message for a RemoveHotlistEditors call.
// Next available tag: 3
type RemoveHotlistEditorsRequest struct {
	// Resource name of the Hotlist to remove editors from.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Resource names of Users associated with the hotlist that should be removed.
	Editors              []string `protobuf:"bytes,2,rep,name=editors,proto3" json:"editors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveHotlistEditorsRequest) Reset()         { *m = RemoveHotlistEditorsRequest{} }
func (m *RemoveHotlistEditorsRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveHotlistEditorsRequest) ProtoMessage()    {}
func (*RemoveHotlistEditorsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{8}
}

func (m *RemoveHotlistEditorsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveHotlistEditorsRequest.Unmarshal(m, b)
}
func (m *RemoveHotlistEditorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveHotlistEditorsRequest.Marshal(b, m, deterministic)
}
func (m *RemoveHotlistEditorsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveHotlistEditorsRequest.Merge(m, src)
}
func (m *RemoveHotlistEditorsRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveHotlistEditorsRequest.Size(m)
}
func (m *RemoveHotlistEditorsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveHotlistEditorsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveHotlistEditorsRequest proto.InternalMessageInfo

func (m *RemoveHotlistEditorsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RemoveHotlistEditorsRequest) GetEditors() []string {
	if m != nil {
		return m.Editors
	}
	return nil
}

// Request message for a GatherHotlistsForUser call.
// Next available tag: 2
type GatherHotlistsForUserRequest struct {
	// Resource name of the user whose hotlists we want to fetch.
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatherHotlistsForUserRequest) Reset()         { *m = GatherHotlistsForUserRequest{} }
func (m *GatherHotlistsForUserRequest) String() string { return proto.CompactTextString(m) }
func (*GatherHotlistsForUserRequest) ProtoMessage()    {}
func (*GatherHotlistsForUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{9}
}

func (m *GatherHotlistsForUserRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GatherHotlistsForUserRequest.Unmarshal(m, b)
}
func (m *GatherHotlistsForUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GatherHotlistsForUserRequest.Marshal(b, m, deterministic)
}
func (m *GatherHotlistsForUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatherHotlistsForUserRequest.Merge(m, src)
}
func (m *GatherHotlistsForUserRequest) XXX_Size() int {
	return xxx_messageInfo_GatherHotlistsForUserRequest.Size(m)
}
func (m *GatherHotlistsForUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GatherHotlistsForUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GatherHotlistsForUserRequest proto.InternalMessageInfo

func (m *GatherHotlistsForUserRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// Response message for a GatherHotlistsForUser call.
// Next available tag: 2
type GatherHotlistsForUserResponse struct {
	Hotlists             []*Hotlist `protobuf:"bytes,1,rep,name=hotlists,proto3" json:"hotlists,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GatherHotlistsForUserResponse) Reset()         { *m = GatherHotlistsForUserResponse{} }
func (m *GatherHotlistsForUserResponse) String() string { return proto.CompactTextString(m) }
func (*GatherHotlistsForUserResponse) ProtoMessage()    {}
func (*GatherHotlistsForUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d85b01edaf10960b, []int{10}
}

func (m *GatherHotlistsForUserResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GatherHotlistsForUserResponse.Unmarshal(m, b)
}
func (m *GatherHotlistsForUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GatherHotlistsForUserResponse.Marshal(b, m, deterministic)
}
func (m *GatherHotlistsForUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatherHotlistsForUserResponse.Merge(m, src)
}
func (m *GatherHotlistsForUserResponse) XXX_Size() int {
	return xxx_messageInfo_GatherHotlistsForUserResponse.Size(m)
}
func (m *GatherHotlistsForUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GatherHotlistsForUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GatherHotlistsForUserResponse proto.InternalMessageInfo

func (m *GatherHotlistsForUserResponse) GetHotlists() []*Hotlist {
	if m != nil {
		return m.Hotlists
	}
	return nil
}

func init() {
	proto.RegisterType((*CreateHotlistRequest)(nil), "monorail.v3.CreateHotlistRequest")
	proto.RegisterType((*GetHotlistRequest)(nil), "monorail.v3.GetHotlistRequest")
	proto.RegisterType((*UpdateHotlistRequest)(nil), "monorail.v3.UpdateHotlistRequest")
	proto.RegisterType((*ListHotlistItemsRequest)(nil), "monorail.v3.ListHotlistItemsRequest")
	proto.RegisterType((*ListHotlistItemsResponse)(nil), "monorail.v3.ListHotlistItemsResponse")
	proto.RegisterType((*RerankHotlistItemsRequest)(nil), "monorail.v3.RerankHotlistItemsRequest")
	proto.RegisterType((*AddHotlistItemsRequest)(nil), "monorail.v3.AddHotlistItemsRequest")
	proto.RegisterType((*RemoveHotlistItemsRequest)(nil), "monorail.v3.RemoveHotlistItemsRequest")
	proto.RegisterType((*RemoveHotlistEditorsRequest)(nil), "monorail.v3.RemoveHotlistEditorsRequest")
	proto.RegisterType((*GatherHotlistsForUserRequest)(nil), "monorail.v3.GatherHotlistsForUserRequest")
	proto.RegisterType((*GatherHotlistsForUserResponse)(nil), "monorail.v3.GatherHotlistsForUserResponse")
}

func init() {
	proto.RegisterFile("api/v3/api_proto/hotlists.proto", fileDescriptor_d85b01edaf10960b)
}

var fileDescriptor_d85b01edaf10960b = []byte{
	// 822 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0xc1, 0x72, 0xe3, 0x44,
	0x10, 0x8d, 0xec, 0xac, 0xe3, 0x6d, 0x63, 0x02, 0x83, 0xb3, 0xeb, 0xd8, 0x04, 0xbc, 0x02, 0x4c,
	0x96, 0xda, 0x92, 0x21, 0x86, 0x03, 0x37, 0x1c, 0x36, 0x0e, 0x09, 0x84, 0x0a, 0x82, 0x70, 0xe0,
	0xa2, 0x1a, 0xdb, 0x1d, 0x5b, 0xd8, 0xd6, 0x88, 0x99, 0x91, 0x8b, 0xe4, 0x03, 0xe0, 0x53, 0x38,
	0x50, 0xfc, 0x05, 0x1f, 0x92, 0x13, 0x1f, 0xc1, 0x89, 0xd2, 0x68, 0x94, 0x44, 0x96, 0x64, 0x87,
	0xe2, 0xc0, 0x51, 0x33, 0xaf, 0x5f, 0xbf, 0xee, 0x9e, 0x7e, 0x82, 0xb7, 0xa9, 0xef, 0x76, 0x16,
	0xdd, 0x0e, 0xf5, 0x5d, 0xc7, 0xe7, 0x4c, 0xb2, 0xce, 0x84, 0xc9, 0x99, 0x2b, 0xa4, 0xb0, 0xd4,
	0x27, 0xa9, 0xcc, 0x99, 0xc7, 0x38, 0x75, 0x67, 0xd6, 0xa2, 0xdb, 0x68, 0xa7, 0xd0, 0x97, 0x48,
	0x65, 0xc0, 0xd1, 0x61, 0x83, 0x1f, 0x71, 0x18, 0x07, 0x35, 0x5a, 0x63, 0xc6, 0xc6, 0x33, 0xec,
	0xa8, 0xaf, 0x41, 0x70, 0xd9, 0xb9, 0x74, 0x71, 0x36, 0x72, 0xe6, 0x54, 0x4c, 0x35, 0xa2, 0xb9,
	0x8c, 0xc0, 0xb9, 0x2f, 0xaf, 0xf4, 0xe5, 0x8b, 0xe8, 0x52, 0xa7, 0xd0, 0xc8, 0x30, 0x75, 0x44,
	0x33, 0xc0, 0x09, 0x5d, 0xb8, 0x8c, 0x6b, 0x74, 0x3b, 0x0f, 0xcd, 0x51, 0xb0, 0x80, 0x0f, 0x51,
	0xe3, 0x9e, 0xe7, 0xe1, 0xa8, 0xe7, 0x31, 0x49, 0xa5, 0xcb, 0x3c, 0xad, 0xdf, 0xfc, 0x12, 0x6a,
	0x9f, 0x73, 0xa4, 0x12, 0xbf, 0x88, 0x9a, 0x61, 0xe3, 0x4f, 0x01, 0x0a, 0x49, 0xba, 0xb0, 0xa5,
	0xdb, 0x53, 0x37, 0x5a, 0xc6, 0x7e, 0xe5, 0xa0, 0x66, 0xdd, 0x6b, 0x8f, 0xa5, 0xd1, 0x87, 0xc5,
	0x9b, 0x5e, 0xc1, 0x8e, 0x91, 0x66, 0x1f, 0x5e, 0x3f, 0x46, 0xb9, 0xc4, 0xf4, 0x11, 0x6c, 0x7a,
	0x74, 0x8e, 0x8a, 0xe6, 0xf1, 0xe1, 0xde, 0x4d, 0xaf, 0xf0, 0x77, 0xef, 0x29, 0xec, 0x50, 0xdf,
	0xb5, 0x86, 0x7c, 0x10, 0x8c, 0xad, 0x21, 0x9b, 0x77, 0xe2, 0x18, 0x05, 0x35, 0x7f, 0x33, 0xa0,
	0x76, 0xe1, 0x8f, 0xd2, 0xaa, 0xce, 0x1e, 0xa6, 0x6a, 0x4d, 0x92, 0x98, 0x83, 0x7c, 0x06, 0x95,
	0x40, 0xa5, 0x51, 0xf3, 0xaa, 0x17, 0x14, 0x65, 0xc3, 0x8a, 0x1a, 0x66, 0xc5, 0x03, 0xb3, 0xfa,
	0xe1, 0x2c, 0xce, 0xa8, 0x98, 0x46, 0xe5, 0x42, 0x14, 0x13, 0x1e, 0x98, 0xbf, 0x1b, 0xf0, 0xf4,
	0x2b, 0x57, 0xc4, 0x35, 0x9f, 0x48, 0x9c, 0x8b, 0x58, 0xec, 0xa7, 0x50, 0xf2, 0x29, 0x47, 0x4f,
	0xea, 0xd2, 0x9f, 0x29, 0x55, 0x4d, 0xb2, 0x9b, 0xa9, 0x2a, 0x0c, 0xb5, 0x75, 0x00, 0x69, 0xc2,
	0x63, 0x9f, 0x8e, 0xd1, 0x11, 0xee, 0x35, 0x2a, 0x59, 0x8f, 0xec, 0x72, 0x78, 0xf0, 0xad, 0x7b,
	0x8d, 0x64, 0x17, 0xca, 0x8c, 0x8f, 0x90, 0x3b, 0x83, 0xab, 0x7a, 0x31, 0x64, 0xb6, 0xb7, 0xd4,
	0xf7, 0xe1, 0x15, 0xd9, 0x03, 0x50, 0x71, 0x92, 0x4d, 0xd1, 0xab, 0x6f, 0xaa, 0x4b, 0xc5, 0xf4,
	0x5d, 0x78, 0x60, 0x72, 0xa8, 0xa7, 0xc5, 0x0a, 0x9f, 0x79, 0x02, 0x89, 0x05, 0x8f, 0xdc, 0xf0,
	0xa0, 0x6e, 0xb4, 0x8a, 0xfb, 0x95, 0x83, 0x7a, 0x56, 0x63, 0x95, 0xc6, 0x08, 0x46, 0xda, 0xb0,
	0xed, 0xe1, 0xcf, 0xd2, 0xb9, 0x97, 0xaf, 0xa0, 0xf2, 0x55, 0xc3, 0xe3, 0xf3, 0xdb, 0x9c, 0x7f,
	0x1a, 0xb0, 0x6b, 0x23, 0xa7, 0xde, 0x34, 0xab, 0x47, 0xff, 0xfe, 0x71, 0x90, 0x3e, 0x54, 0xf5,
	0xfc, 0x9c, 0x48, 0x70, 0xa1, 0x55, 0xbc, 0xeb, 0x2e, 0xac, 0xe8, 0xee, 0x2b, 0x93, 0x7b, 0x0a,
	0xc8, 0x0b, 0xd8, 0x96, 0x94, 0x8f, 0x51, 0x3a, 0x3e, 0x13, 0x6e, 0xb8, 0x13, 0xaa, 0x9b, 0xd5,
	0x68, 0xc8, 0xaf, 0x46, 0x77, 0xe7, 0xfa, 0xca, 0xfc, 0xc3, 0x80, 0x27, 0xbd, 0xd1, 0x28, 0xab,
	0x86, 0x4f, 0x96, 0xe6, 0xbc, 0xa6, 0x8a, 0x78, 0xc6, 0x5d, 0x28, 0xb9, 0x42, 0x04, 0x18, 0x17,
	0xd0, 0x54, 0x61, 0x3b, 0xf0, 0x46, 0x32, 0xec, 0x24, 0xc4, 0xd8, 0x1a, 0x4a, 0xde, 0xcf, 0x11,
	0x9d, 0xd2, 0xfb, 0xab, 0x6a, 0xfb, 0x9c, 0x2d, 0xf0, 0x7f, 0x96, 0x6c, 0xfe, 0x62, 0x40, 0x33,
	0xa1, 0xe4, 0x68, 0xe4, 0x4a, 0xc6, 0xff, 0xcb, 0x13, 0xf8, 0x18, 0xb6, 0x30, 0x22, 0xd1, 0x42,
	0x1a, 0x2a, 0xaa, 0x06, 0x24, 0x19, 0x75, 0x21, 0x90, 0xdb, 0x31, 0xd4, 0xfc, 0x1a, 0xde, 0x3c,
	0xa6, 0x72, 0x82, 0x5c, 0x93, 0x89, 0x3e, 0xe3, 0x0a, 0xa1, 0x85, 0x58, 0xb0, 0x19, 0x08, 0xe4,
	0x5a, 0xc8, 0x2a, 0x4a, 0x85, 0x33, 0xbf, 0x81, 0xbd, 0x1c, 0x3e, 0xbd, 0x52, 0x1f, 0x42, 0x39,
	0xfe, 0xc5, 0xe8, 0xad, 0xca, 0xb4, 0x2b, 0xfb, 0x16, 0x75, 0xf0, 0x57, 0x09, 0xca, 0x31, 0x1b,
	0x39, 0x85, 0x6a, 0xc2, 0x9a, 0xc9, 0xb3, 0x44, 0x74, 0x96, 0x6d, 0x37, 0x32, 0x13, 0x98, 0x1b,
	0xe4, 0x25, 0xc0, 0x9d, 0x33, 0x93, 0xb7, 0x12, 0xa8, 0x94, 0x65, 0xe7, 0xb2, 0x9c, 0x42, 0x35,
	0x61, 0xcb, 0x4b, 0x8a, 0xb2, 0x2c, 0x3b, 0x97, 0xeb, 0x04, 0xaa, 0x2f, 0x71, 0x86, 0x77, 0x5c,
	0xeb, 0x44, 0x3d, 0x49, 0xf9, 0xf2, 0x51, 0xf8, 0x23, 0x35, 0x37, 0x08, 0x85, 0xd7, 0x96, 0x6d,
	0x8d, 0xbc, 0x9b, 0x60, 0xcb, 0xb1, 0xe8, 0xc6, 0x7b, 0x6b, 0x50, 0xd1, 0x20, 0xcd, 0x0d, 0xf2,
	0x3d, 0x90, 0xb4, 0x89, 0x91, 0x76, 0x22, 0x3c, 0xd7, 0xe5, 0x56, 0x48, 0x3f, 0x87, 0xed, 0x25,
	0x57, 0x21, 0xef, 0x24, 0x48, 0xb3, 0x3d, 0x67, 0x05, 0xa3, 0x52, 0xba, 0xbc, 0xf7, 0x29, 0xa5,
	0x39, 0xc6, 0xb0, 0x82, 0xf7, 0x07, 0xa8, 0x65, 0x6d, 0x31, 0xd9, 0xcf, 0x67, 0x4e, 0x2e, 0xfa,
	0x0a, 0x6e, 0x1f, 0x76, 0x32, 0x37, 0x89, 0x3c, 0x4f, 0xbe, 0x89, 0x15, 0xdb, 0xdb, 0xf8, 0xe0,
	0x21, 0xd0, 0x78, 0x9e, 0x83, 0x92, 0xd2, 0xd0, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x36,
	0xf3, 0x7f, 0x15, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// HotlistsClient is the client API for Hotlists service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HotlistsClient interface {
	// Creates a new hotlist.
	//
	// Raises:
	//   NOT_FOUND if some given hotlist editors do not exist.
	//   ALREADY_EXISTS if a hotlist with the same name owned by the user
	//   already exists.
	//   INVALID_ARGUMENT if a `hotlist.owner` is given.
	CreateHotlist(ctx context.Context, in *CreateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error)
	// Returns the requested Hotlist.
	//
	// Raises:
	//   NOT_FOUND if the requested hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to view the hotlist.
	//   INVALID_ARGUMENT if the given resource name is not valid.
	GetHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error)
	// Updates a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to update the hotlist.
	//   INVALID_ARGUMENT if required fields are missing.
	UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error)
	// Deletes a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to delete the hotlist.
	DeleteHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Returns a list of all HotlistItems in the hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to view the hotlist.
	//   INVALID_ARGUMENT if the page_token or given hotlist resource name is not
	//   valid.
	ListHotlistItems(ctx context.Context, in *ListHotlistItemsRequest, opts ...grpc.CallOption) (*ListHotlistItemsResponse, error)
	// Reranks a hotlist's items.
	//
	// Raises:
	//   NOT_FOUND if the hotlist or issues to rerank are not found.
	//   PERMISSION_DENIED if the requester is not allowed to rerank the hotlist
	//   or view issues they're trying to rerank.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Adds new items associated with given issues to a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist or issues are not found.
	//   PERMISSION_DENIED if the requester is not allowed to edit the hotlist or
	//   view issues they are trying to add.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	AddHotlistItems(ctx context.Context, in *AddHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Removes items associated with given issues from a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist or issues are not found.
	//   PERMISSION_DENIED if the requester is not allowed to edit the hotlist or
	//   view issues they are trying to remove.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RemoveHotlistItems(ctx context.Context, in *RemoveHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Removes editors assigned to a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to remove all specified
	//   editors from the hotlist.
	//   INVALID_ARGUMENT if any specified editors are not in the hotlist.
	RemoveHotlistEditors(ctx context.Context, in *RemoveHotlistEditorsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gathers all viewable hotlists that a user is a member of.
	//
	// Raises:
	//   NOT_FOUND if the user is not found.
	//   INVALID_ARGUMENT if the `user` is invalid.
	GatherHotlistsForUser(ctx context.Context, in *GatherHotlistsForUserRequest, opts ...grpc.CallOption) (*GatherHotlistsForUserResponse, error)
}
type hotlistsPRPCClient struct {
	client *prpc.Client
}

func NewHotlistsPRPCClient(client *prpc.Client) HotlistsClient {
	return &hotlistsPRPCClient{client}
}

func (c *hotlistsPRPCClient) CreateHotlist(ctx context.Context, in *CreateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "CreateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) GetHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "GetHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "UpdateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) DeleteHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "DeleteHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) ListHotlistItems(ctx context.Context, in *ListHotlistItemsRequest, opts ...grpc.CallOption) (*ListHotlistItemsResponse, error) {
	out := new(ListHotlistItemsResponse)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "ListHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "RerankHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) AddHotlistItems(ctx context.Context, in *AddHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "AddHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) RemoveHotlistItems(ctx context.Context, in *RemoveHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "RemoveHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) RemoveHotlistEditors(ctx context.Context, in *RemoveHotlistEditorsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "RemoveHotlistEditors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsPRPCClient) GatherHotlistsForUser(ctx context.Context, in *GatherHotlistsForUserRequest, opts ...grpc.CallOption) (*GatherHotlistsForUserResponse, error) {
	out := new(GatherHotlistsForUserResponse)
	err := c.client.Call(ctx, "monorail.v3.Hotlists", "GatherHotlistsForUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type hotlistsClient struct {
	cc grpc.ClientConnInterface
}

func NewHotlistsClient(cc grpc.ClientConnInterface) HotlistsClient {
	return &hotlistsClient{cc}
}

func (c *hotlistsClient) CreateHotlist(ctx context.Context, in *CreateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/CreateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) GetHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/GetHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) UpdateHotlist(ctx context.Context, in *UpdateHotlistRequest, opts ...grpc.CallOption) (*Hotlist, error) {
	out := new(Hotlist)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/UpdateHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) DeleteHotlist(ctx context.Context, in *GetHotlistRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/DeleteHotlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) ListHotlistItems(ctx context.Context, in *ListHotlistItemsRequest, opts ...grpc.CallOption) (*ListHotlistItemsResponse, error) {
	out := new(ListHotlistItemsResponse)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/ListHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) RerankHotlistItems(ctx context.Context, in *RerankHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/RerankHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) AddHotlistItems(ctx context.Context, in *AddHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/AddHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) RemoveHotlistItems(ctx context.Context, in *RemoveHotlistItemsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/RemoveHotlistItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) RemoveHotlistEditors(ctx context.Context, in *RemoveHotlistEditorsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/RemoveHotlistEditors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hotlistsClient) GatherHotlistsForUser(ctx context.Context, in *GatherHotlistsForUserRequest, opts ...grpc.CallOption) (*GatherHotlistsForUserResponse, error) {
	out := new(GatherHotlistsForUserResponse)
	err := c.cc.Invoke(ctx, "/monorail.v3.Hotlists/GatherHotlistsForUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HotlistsServer is the server API for Hotlists service.
type HotlistsServer interface {
	// Creates a new hotlist.
	//
	// Raises:
	//   NOT_FOUND if some given hotlist editors do not exist.
	//   ALREADY_EXISTS if a hotlist with the same name owned by the user
	//   already exists.
	//   INVALID_ARGUMENT if a `hotlist.owner` is given.
	CreateHotlist(context.Context, *CreateHotlistRequest) (*Hotlist, error)
	// Returns the requested Hotlist.
	//
	// Raises:
	//   NOT_FOUND if the requested hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to view the hotlist.
	//   INVALID_ARGUMENT if the given resource name is not valid.
	GetHotlist(context.Context, *GetHotlistRequest) (*Hotlist, error)
	// Updates a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to update the hotlist.
	//   INVALID_ARGUMENT if required fields are missing.
	UpdateHotlist(context.Context, *UpdateHotlistRequest) (*Hotlist, error)
	// Deletes a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to delete the hotlist.
	DeleteHotlist(context.Context, *GetHotlistRequest) (*empty.Empty, error)
	// Returns a list of all HotlistItems in the hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to view the hotlist.
	//   INVALID_ARGUMENT if the page_token or given hotlist resource name is not
	//   valid.
	ListHotlistItems(context.Context, *ListHotlistItemsRequest) (*ListHotlistItemsResponse, error)
	// Reranks a hotlist's items.
	//
	// Raises:
	//   NOT_FOUND if the hotlist or issues to rerank are not found.
	//   PERMISSION_DENIED if the requester is not allowed to rerank the hotlist
	//   or view issues they're trying to rerank.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RerankHotlistItems(context.Context, *RerankHotlistItemsRequest) (*empty.Empty, error)
	// Adds new items associated with given issues to a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist or issues are not found.
	//   PERMISSION_DENIED if the requester is not allowed to edit the hotlist or
	//   view issues they are trying to add.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	AddHotlistItems(context.Context, *AddHotlistItemsRequest) (*empty.Empty, error)
	// Removes items associated with given issues from a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the parent hotlist or issues are not found.
	//   PERMISSION_DENIED if the requester is not allowed to edit the hotlist or
	//   view issues they are trying to remove.
	//   INVALID_ARGUMENT if the `target_position` is invalid or `hotlist_items`
	//   is empty or contains items not in the Hotlist.
	RemoveHotlistItems(context.Context, *RemoveHotlistItemsRequest) (*empty.Empty, error)
	// Removes editors assigned to a hotlist.
	//
	// Raises:
	//   NOT_FOUND if the hotlist is not found.
	//   PERMISSION_DENIED if the requester is not allowed to remove all specified
	//   editors from the hotlist.
	//   INVALID_ARGUMENT if any specified editors are not in the hotlist.
	RemoveHotlistEditors(context.Context, *RemoveHotlistEditorsRequest) (*empty.Empty, error)
	// Gathers all viewable hotlists that a user is a member of.
	//
	// Raises:
	//   NOT_FOUND if the user is not found.
	//   INVALID_ARGUMENT if the `user` is invalid.
	GatherHotlistsForUser(context.Context, *GatherHotlistsForUserRequest) (*GatherHotlistsForUserResponse, error)
}

// UnimplementedHotlistsServer can be embedded to have forward compatible implementations.
type UnimplementedHotlistsServer struct {
}

func (*UnimplementedHotlistsServer) CreateHotlist(ctx context.Context, req *CreateHotlistRequest) (*Hotlist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHotlist not implemented")
}
func (*UnimplementedHotlistsServer) GetHotlist(ctx context.Context, req *GetHotlistRequest) (*Hotlist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHotlist not implemented")
}
func (*UnimplementedHotlistsServer) UpdateHotlist(ctx context.Context, req *UpdateHotlistRequest) (*Hotlist, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHotlist not implemented")
}
func (*UnimplementedHotlistsServer) DeleteHotlist(ctx context.Context, req *GetHotlistRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHotlist not implemented")
}
func (*UnimplementedHotlistsServer) ListHotlistItems(ctx context.Context, req *ListHotlistItemsRequest) (*ListHotlistItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHotlistItems not implemented")
}
func (*UnimplementedHotlistsServer) RerankHotlistItems(ctx context.Context, req *RerankHotlistItemsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RerankHotlistItems not implemented")
}
func (*UnimplementedHotlistsServer) AddHotlistItems(ctx context.Context, req *AddHotlistItemsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHotlistItems not implemented")
}
func (*UnimplementedHotlistsServer) RemoveHotlistItems(ctx context.Context, req *RemoveHotlistItemsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveHotlistItems not implemented")
}
func (*UnimplementedHotlistsServer) RemoveHotlistEditors(ctx context.Context, req *RemoveHotlistEditorsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveHotlistEditors not implemented")
}
func (*UnimplementedHotlistsServer) GatherHotlistsForUser(ctx context.Context, req *GatherHotlistsForUserRequest) (*GatherHotlistsForUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GatherHotlistsForUser not implemented")
}

func RegisterHotlistsServer(s prpc.Registrar, srv HotlistsServer) {
	s.RegisterService(&_Hotlists_serviceDesc, srv)
}

func _Hotlists_CreateHotlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHotlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).CreateHotlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/CreateHotlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).CreateHotlist(ctx, req.(*CreateHotlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_GetHotlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHotlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).GetHotlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/GetHotlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).GetHotlist(ctx, req.(*GetHotlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_UpdateHotlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHotlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).UpdateHotlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/UpdateHotlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).UpdateHotlist(ctx, req.(*UpdateHotlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_DeleteHotlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHotlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).DeleteHotlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/DeleteHotlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).DeleteHotlist(ctx, req.(*GetHotlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_ListHotlistItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHotlistItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).ListHotlistItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/ListHotlistItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).ListHotlistItems(ctx, req.(*ListHotlistItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_RerankHotlistItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankHotlistItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).RerankHotlistItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/RerankHotlistItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).RerankHotlistItems(ctx, req.(*RerankHotlistItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_AddHotlistItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHotlistItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).AddHotlistItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/AddHotlistItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).AddHotlistItems(ctx, req.(*AddHotlistItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_RemoveHotlistItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveHotlistItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).RemoveHotlistItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/RemoveHotlistItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).RemoveHotlistItems(ctx, req.(*RemoveHotlistItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_RemoveHotlistEditors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveHotlistEditorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).RemoveHotlistEditors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/RemoveHotlistEditors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).RemoveHotlistEditors(ctx, req.(*RemoveHotlistEditorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hotlists_GatherHotlistsForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatherHotlistsForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HotlistsServer).GatherHotlistsForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monorail.v3.Hotlists/GatherHotlistsForUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HotlistsServer).GatherHotlistsForUser(ctx, req.(*GatherHotlistsForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Hotlists_serviceDesc = grpc.ServiceDesc{
	ServiceName: "monorail.v3.Hotlists",
	HandlerType: (*HotlistsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHotlist",
			Handler:    _Hotlists_CreateHotlist_Handler,
		},
		{
			MethodName: "GetHotlist",
			Handler:    _Hotlists_GetHotlist_Handler,
		},
		{
			MethodName: "UpdateHotlist",
			Handler:    _Hotlists_UpdateHotlist_Handler,
		},
		{
			MethodName: "DeleteHotlist",
			Handler:    _Hotlists_DeleteHotlist_Handler,
		},
		{
			MethodName: "ListHotlistItems",
			Handler:    _Hotlists_ListHotlistItems_Handler,
		},
		{
			MethodName: "RerankHotlistItems",
			Handler:    _Hotlists_RerankHotlistItems_Handler,
		},
		{
			MethodName: "AddHotlistItems",
			Handler:    _Hotlists_AddHotlistItems_Handler,
		},
		{
			MethodName: "RemoveHotlistItems",
			Handler:    _Hotlists_RemoveHotlistItems_Handler,
		},
		{
			MethodName: "RemoveHotlistEditors",
			Handler:    _Hotlists_RemoveHotlistEditors_Handler,
		},
		{
			MethodName: "GatherHotlistsForUser",
			Handler:    _Hotlists_GatherHotlistsForUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v3/api_proto/hotlists.proto",
}
