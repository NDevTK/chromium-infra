<meta charset="utf-8">
<script src="/bower_components/web-component-tester/browser.js"></script>

<script type="module">
import ClientLogger from '../../static/js/monitoring/client-logger.js';
import MonorailTSMon from '../../static/js/monitoring/ts-mon.js';

suite('ClientLogger', () => {

  setup(() => {
    window.CS_env = {
      token: 'rutabaga-token',
      tokenExpiresSec: 1234,
      app_version: 'rutabaga-version',
    };
    window.chops = {rpc: {PrpcClient: sinon.spy()}};
    window.ga = sinon.spy();
    MonorailTSMon.prototype.disableAfterNextFlush = sinon.spy();
  });

  suite('constructor', function() {
    test('assigns this.category', function() {
      const c = new ClientLogger('rutabaga');
      assert.equal(c.category, 'rutabaga');
    });

    test('gets started events from sessionStorage', function() {
      const startedEvents = {
        event1: {
          time: 12345678,
          labels: ['label1', 'label2'],
        },
        event2: {
          time: 87654321,
          labels: ['label2'],
        },
      };
      const key = 'ClientLogger.rutabaga.started';
      sessionStorage[key] = JSON.stringify(startedEvents);

      const c = new ClientLogger('rutabaga');
      assert.deepEqual(startedEvents, c.startedEvents);
    });
  });

  suite('records ts_mon metrics', function() {
    let issueCreateMetric;
    let issueUpdateMetric;
    let autocompleteMetric;
    let c;

    setup(() => {
      window.ga = sinon.spy();
      c = new ClientLogger('issues');
      issueCreateMetric = c.tsMon._userTimingMetrics[0].metric;
      issueCreateMetric.add = sinon.spy();

      issueUpdateMetric = c.tsMon._userTimingMetrics[1].metric;
      issueUpdateMetric.add = sinon.spy();

      autocompleteMetric = c.tsMon._userTimingMetrics[2].metric;
      autocompleteMetric.add = sinon.spy();
    });

    test('bogus', () => {
      c.logStart('rutabaga');
      c.logEnd('rutabaga');
      sinon.assert.notCalled(issueCreateMetric.add);
      sinon.assert.notCalled(issueUpdateMetric.add);
      sinon.assert.notCalled(autocompleteMetric.add);
    });

    test('new-issue', () => {
      c.logStart('new-issue');
      c.logEnd('new-issue');
      sinon.assert.notCalled(issueUpdateMetric.add);
      sinon.assert.notCalled(autocompleteMetric.add);

      sinon.assert.calledOnce(issueCreateMetric.add);
      assert.isNumber(issueCreateMetric.add.getCall(0).args[0]);
      assert.isString(issueCreateMetric.add.getCall(0).args[1].get('client_id'));
      assert.equal(issueCreateMetric.add.getCall(0).args[1].get('host_name'),
        'rutabaga-version');
    });

    test('issue-update', () => {
      c.logStart('issue-update');
      c.logEnd('issue-update');
      sinon.assert.notCalled(issueCreateMetric.add);
      sinon.assert.notCalled(autocompleteMetric.add);

      sinon.assert.calledOnce(issueUpdateMetric.add);
      assert.isNumber(issueUpdateMetric.add.getCall(0).args[0]);
      assert.isString(issueUpdateMetric.add.getCall(0).args[1].get('client_id'));
      assert.equal(issueUpdateMetric.add.getCall(0).args[1].get('host_name'),
        'rutabaga-version');
    });

    test('populate-options', () => {
      c.logStart('populate-options');
      c.logEnd('populate-options');
      sinon.assert.notCalled(issueCreateMetric.add);
      sinon.assert.notCalled(issueUpdateMetric.add);
      // Autocomplete is not called in issues category.
      sinon.assert.notCalled(autocompleteMetric.add);

      c = new ClientLogger('autocomplete');
      autocompleteMetric = c.tsMon._userTimingMetrics[2].metric;
      autocompleteMetric.add = sinon.spy();

      c.logStart('populate-options');
      c.logEnd('populate-options');
      sinon.assert.notCalled(issueCreateMetric.add);
      sinon.assert.notCalled(issueUpdateMetric.add);

      sinon.assert.calledOnce(autocompleteMetric.add);
      assert.isNumber(autocompleteMetric.add.getCall(0).args[0]);
      assert.isString(autocompleteMetric.add.getCall(0).args[1].get('client_id'));
      assert.equal(autocompleteMetric.add.getCall(0).args[1].get('host_name'),
        'rutabaga-version');
    });
  });

  suite('logEnd', () => {
    let c, clock;
    setup(() => {
      c = new ClientLogger('rutabaga');
      clock = sinon.useFakeTimers(1000);
      c.tsMon.recordUserTiming = sinon.spy();
    });

    teardown(() => {
      clock.restore();
    });

    test('throws an error if no event was started', () => {
      c.startedEvents = {someEvent: {}};
      assert.throws(() => {
        c.logEnd('bogus');
      });
      sinon.assert.notCalled(window.ga);
    });

    test('calls ga() with timing and event info', () => {
      c.startedEvents = {someEvent: {time: 900}};
      c.logEnd('someEvent');

      assert.deepEqual(window.ga.getCall(0).args, [
        'send', 'timing', {
          timingCategory: 'rutabaga',
          timingValue: 100,
          timingVar: 'someEvent',
      }]);
      assert.deepEqual(window.ga.getCall(1).args, [
        'send', 'event', 'rutabaga', 'someEvent-end', undefined, undefined
      ]);
      sinon.assert.calledWith(c.tsMon.recordUserTiming, 'rutabaga',
        'someEvent', 100);
    });

    test('does not log events over threshold', () => {
      c.startedEvents = {rutabaga: {time: 900}};
      c.logEnd('rutabaga', null, 99);

      sinon.assert.notCalled(window.ga);
      sinon.assert.notCalled(c.tsMon.recordUserTiming);
    });
  });
});
</script>
