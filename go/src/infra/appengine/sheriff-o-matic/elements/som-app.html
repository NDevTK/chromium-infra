<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="/bower_components/iron-flex-layout/classes/iron-flex-layout.html">
<link rel="import" href="/bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="/bower_components/iron-icon/iron-icon.html">
<link rel="import" href="/bower_components/iron-icons/iron-icons.html">
<link rel="import" href="/bower_components/iron-list/iron-list.html">
<link rel="import" href="/bower_components/iron-location/iron-location.html">
<link rel="import" href="/bower_components/iron-pages/iron-pages.html">
<link rel="import" href="/bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="/bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="/bower_components/paper-badge/paper-badge.html">
<link rel="import" href="/bower_components/paper-button/paper-button.html">
<link rel="import" href="/bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="/bower_components/paper-drawer-panel/paper-drawer-panel.html">
<link rel="import" href="/bower_components/paper-header-panel/paper-header-panel.html">
<link rel="import" href="/bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/bower_components/paper-input/paper-input.html">
<link rel="import" href="/bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="/bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="/elements/som-alert-item.html">
<link rel="import" href="/elements/som-bug-queue.html">
<link rel="import" href="/elements/som-drawer.html">
<link rel="import" href="/elements/som-examine.html">

<dom-module id="som-app">
  <template>
    <style>
      paper-toolbar {
        --paper-toolbar-background: black;
      }
      paper-header-panel /deep/ #mainContainer {
        @apply(--layout-vertical);
      }
      .last-updated, .user-name {
        text-align: right;
        padding-right: 1em;
      }
      #alerts {
        @apply(--layout-vertical);
        @apply(--center-justified);
        margin: 0 auto;
        padding: 8px;
        height: 100%;
      }
      paper-header-panel[main] {
        --paper-header-panel-body: {
          background: #eee;
        }
      }
     .title {
        font-size: big;
      }
      .som-title {
        font-weight: bold;
      }
      iron-list {
        overflow: none;
        --iron-list-items-container: {
          margin: auto;
          margin-bottom: 60px;
          border-bottom: 1px solid #ddd;
        };
      }
      .list-item {
        @apply(--layout-flex);
        @apply(--layout-vertical);
        margin-bottom: 10px;
      }
      .file-bug,
      .snooze {
        color: #aaa;
      }
      #refresh {
        width: 25px;
        height: 25px;
        padding: 0;
      }
    </style>
    <iron-location id="url" path="{{_path}}"></iron-location>
    <iron-ajax
        auto
        id="annotations"
        url="/api/v1/annotations"
        handle-as="json"
        last-error="{{_annotationsJsonError}}"
        last-response="{{annotationsJson}}"
        debounce-duration="300"></iron-ajax>
    <iron-ajax
        id="annotationPost"
        method="post"
        handle-as="json"
        last-error="{{_annotationPostError}}"
        on-response="_postResponse"></iron-ajax>
    <paper-drawer-panel responsive-width="1024px">
      <paper-header-panel drawer>
        <paper-toolbar>
          <span class="som-title">Sheriff-o-Matic</span>
        </paper-toolbar>
        <som-drawer id="drawer" tree="[[_tree]]" path="{{_path}}" show-infra-failures="{{showInfraFailures}}" trees="{{_trees}}"></som-drawer>
      </paper-header-panel>
      <paper-header-panel main class="flex layout vertical">
        <paper-toolbar>
          <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
          <div class="layout horizontal flex">
            <div class="flex title">[[_tree]]</div>
            <div hidden$="[[_lastUpdate]]" class="flex last-updated">
              Last updated: [[_lastUpdated]]
            </div>
            <div class="user-name">
              [[user]] (<a href$="[[logoutUrl]]">Log Out </a>)
            </div>
            <paper-icon-button on-tap="_refresh" id="refresh" icon="refresh"></paper-icon-button>
          </div>
          <paper-spinner active="[[_fetchingAlerts]]"></paper-spinner>
        </paper-toolbar>
        <div class="flex layout vertical">
          <iron-pages attr-for-selected='id' selected="[[_selectedPage]]" class="flex layout vertical">
            <div id="alertsList">
             <som-bug-queue id="bugQueue" alerts-group="[[_alertsGroup]]"></som-bug-queue>
             <div hidden$="[[_haveAlerts]]">
                No alerts!
              </div>
              <iron-list id="alertsIronList" items="[[_alerts]]" as="alert" selection-enabled multi-selection>
                <template>
                  <div class="list-item" tabindex$="[[tabIndex]]">
                    <som-alert-item
                        alert="{{alert}}"
                        tree="[[_tree]]"
                        selected="[[selected]]"
                        annotation="[[_computeAnnotation(annotations, alert)]]"
                        on-annotation-change="_handleAnnotation"
                        on-link-bug="_handleLinkBug"
                    ></som-alert-item>
                  </div>
                </template>
              </iron-list>
            </div>
            <div id="examineAlert" class="flex layout vertical">
              <som-examine alert="[[_examinedAlert]]" class="flex layout vertical"></som-examine>
            </div>
          </iron-pages>
        </div>
      </paper-header-panel>
    </paper-drawer-panel>
    <paper-dialog id="bugDialog" with-backdrop entry-animation="scale-up-animation" exit-animation="fade-out-animation">
      <h2>Enter bug number</h2>
      <paper-input autofocus id="bug" label="Bug # or URL"></paper-input>
      <a hidden$="[[_filedBug]]" id="fileBugLink" target="_blank" on-tap="_fileBugClicked">
        File bug
      </a>
      <div hidden$="[[!_filedBug]]" id="bugReminder">
        Remember to enter the new bug number above!
      </div>
      <div class="buttons">
        <paper-button dialog-close raised on-tap="_closeBugDialog">
          Close
        </paper-button>
        <paper-button dialog-confirm raised on-tap="_saveBug">
          Save Bug
        </paper-button>
      </div>
    </paper-dialog>
  </template>
  <script>
  (function() {
    'use strict';

    // Time, in milliseconds, between each refresh of data from the server.
    const refreshDelayMs = 60 * 1000;

    Polymer({
      is: 'som-app',
      properties: {
        _activeRequests: {
          type: Number,
          value: function() { return 0; },
        },
        _alerts: {
          type: Array,
          value: function() { return []; },
          computed: '_computeAlerts(_alertsData.*, annotations, showInfraFailures)',
        },
        // Map of stream to data, timestamp of latest updated data.
        _alertsData: {
          type: Object,
          value: function() { return {}; },
        },
        _alertsTimes: {
          type: Object,
          value: function() { return {}; },
        },
        _alertsGroups: {
          type: Array,
          computed: '_computeAlertsGroup(_tree, _trees)',
          observer: '_alertsGroupChanged',
        },
        // We don't convert the array into an object because the polymer data
        // binding doesn't seem to like mutations to an object, but it's fine
        // watching and notifying about changes to an array :/
        annotations: {
          type: Object,
          computed: '_computeAnnotations(annotationsJson)',
        },
        annotationsJson: Array,
        _lastUpdated: {
          type: Date,
          computed: '_computeLastUpdated(_alertsTimes.*)',
        },
        _annotationsJsonError: {
          type: Object,
          value: function() { return {}; },
        },
        _annotationPostError: {
          type: Object,
          value: function() { return {}; },
        },
        _bugModel: Object,
        _filedBug: {
          type: Boolean,
          value: false,
        },
        _haveAlerts: {
          type: Boolean,
          computed: '_computeHaveAlerts(_alerts)',
        },
        _fetchingAlerts: {
          type: Boolean,
          computed: '_computeFetchingAlerts(_activeRequests)',
        },
        logoutUrl: String,
        _path: {
          type: String,
        },
        _selectedPage: {
          type: String,
          computed: '_computeSelectedPage(_path)',
        },
        showInfraFailures: {
          type: Boolean,
          value: true,
        },
        _trees: Object,
        _tree: {
          type: String,
          computed: '_computeTree(_path)',
        },
        _examinedAlert: {
          type: Object,
          computed: '_computeExaminedAlert(_alerts, _examinedAlertKey)',
        },
        _examinedAlertKey: {
          type: String,
          computed: '_computeExaminedAlertKey(_path)',
        },
        user: String,
      },

      created: function() {
        this.async(this._refreshAsync, refreshDelayMs);
      },

      ////////////////////// Refresh ///////////////////////////

      _refresh: function() {
<<<<<<< c4f4bdb83d993152d97b7ad2f63bf9a7d79fe5c4
        this.$.alertsAjax.generateRequest();
        this.$.bugQueue.refresh();
=======
        this.$.annotations.generateRequest();
>>>>>>> Comments
        this._alertsGroupChanged(this._alertsGroups);
      },

      _refreshAsync: function() {
        this._refresh();
        this.async(this._refreshAsync, refreshDelayMs);
      },

      ////////////////////// Alerts and path ///////////////////////////

      _computeTree: function(path) {
        let pathParts = path.split('/');
        if (pathParts.length < 2 || pathParts[1] == "") {
          console.error('error: invalid pathParts', pathParts);
          return "";
        }

        return pathParts[1];
      },

      _computeAlertsGroup: function(tree, trees) {
        if (tree === '') {
          return [];
        }

        if (trees && trees[tree] && trees[tree].alert_streams) {
          return trees[tree].alert_streams
        }

        return [tree];
      },

      _computeSelectedPage: function(path) {
        let pathParts = path.split('/');
        if (pathParts.length < 2) {
          console.error('error: pathParts < 2', pathParts);
        }
        if (pathParts.length < 3) {
          return 'alertsList';
        }
        if (pathParts[2] == 'examine') {
          return 'examineAlert';
        }
      },

      _computeExaminedAlertKey: function(path) {
        let pathParts = path.split('/');
        if (pathParts.length < 2) {
          console.error('error: pathParts < 2', pathParts);
        }

        if (pathParts.length < 3) {
          return '';
        }

        if (pathParts[2] == 'examine') {
          if (pathParts.length > 3) {
            // Let som-examine element deal with the rest of the path.
            return window.unescape(pathParts.slice(3).join('/'));
          }
        }
      },

      _computeExaminedAlert: function(alerts, examinedAlertKey) {
        let examinedAlert = alerts.find( (alert) => {
          return alert.key == examinedAlertKey;
        });
        // Two possibilities if examinedAlert is undefined:
        // 1. The alert key is bad.
        // 2. Alerts has not been ajaxed in yet.
        if (examinedAlert) {
          return examinedAlert;
        }
      },

      _computeLastUpdated: function(alertsTimes) {
        alertsTimes = alertsTimes.base;

        // Alert streams are assumed to be always older than right now.
        let oldestDate = new Date();
        Object.keys(alertsTimes).forEach((tree) => {
          if (alertsTimes[tree] < oldestDate) {
            oldestDate = alertsTimes[tree];
          }
        });

        // Assume it takes less than 1 millisecond to calculate that.
        if (Date.now() - oldestDate > 1) {
          return new Date(oldestDate * 1000).toLocaleString();
        }
        return 'Unknown';
      },

      _alertsGroupChanged: function(alertsGroup) {
        this.set('_activeRequests', this._activeRequests + alertsGroup.length);

        // TODO: handle webpage offline throwing an exception
        alertsGroup.forEach((group) => {
          fetch('/api/v1/alerts/' + group, {credentials: 'include'}).then((response) => {
            // TODO: handle alerts not found
            this.set('_activeRequests', this._activeRequests - 1);
            return response.json();
          }).then( (json) => {
            this.set(['_alertsData', group], json.alerts);
            this.set(['_alertsTimes', group], json.timestamp);
          });
        });
      },

      _computeFetchingAlerts: function(activeRequests) {
        return activeRequests !== 0;
      },

      _computeAlerts: function(alertsData, annotations, showInfraFailures) {
        if (!alertsData || !alertsData.base) {
          return [];
        }
        alertsData = alertsData.base;

        let allAlerts = [];
        for (let tree in alertsData) {
          let alerts = alertsData[tree];
          if (!showInfraFailures) {
            alerts = alerts.filter(function(alert) {
              return alert.type !== 'infra-failure';
            });
          }
          allAlerts = allAlerts.concat(alerts);
        }

        allAlerts.sort((a, b) => {
          let aAnn = this._computeAnnotation(annotations, a);
          let bAnn = this._computeAnnotation(annotations, b);

          if (aAnn.snoozed == bAnn.snoozed) {
            return a.severity - b.severity;
          }

          return aAnn.snoozed ? 1 : -1;
        });

        // Otherwise alertsIronList doesn't render all of the alert items.
        setTimeout(() => {
          this.$.alertsIronList.notifyResize();
        }, 250);

        return allAlerts;
      },

      _computeHaveAlerts: function(alerts) {
        if (!alerts) {
          return true;
        }
        return alerts.length > 0;
      },

      ////////////////////// Annotations ///////////////////////////

      _computeAnnotations: function(annotationsJson) {
        let annotations = {};
        if (!annotationsJson) {
          return annotations;
        }
        annotationsJson.forEach(function(annotation) {
          annotations[annotation.key] = annotation;
        });
        return annotations;
      },

      _computeAnnotation: function(annotations, alert) {
        let key = this._keyForAlert(alert);

        let ann = annotations[key];
        return {
          key: key,
          snoozed: ann && ann.snoozeTime ? Date.now() < ann.snoozeTime : false,
          bugs: ann && ann.bugs,
        };
      },

      _handleAnnotation: function(evt) {
        this._sendAnnotation(
          this._keyForAlert(evt.model.alert), evt.detail.type,
          evt.detail.change);
      },

      _postResponse: function(evt) {
        let response = evt.detail.response;
        let annotations = this.annotations;
        annotations[response.key] = response;
        let newArray = [];
        Object.keys(annotations).forEach(function(k) {
          newArray.push(annotations[k]);
        });
        this.annotationsJson = newArray;
        // Kind of a cheat: we aren't resizing anything necessarily but we
        // do want to tickle the list order.
        setTimeout( ()=> {
          this.$.alertsIronList.notifyResize();
        }, 250);
      },

      _sendAnnotation: function(key, type, change) {
        this.$.annotationPost.body = JSON.stringify(change);
        this.$.annotationPost.url = '/api/v1/annotations/' + key + '/' + type;
        this.$.annotationPost.generateRequest();
      },

      _keyForAlert: function(alert) {
        if (alert.extension && alert.extension.reasons &&
            alert.extension.builders) {
          return alert.extension.reasons.map(function(reason) {
            return reason.step;
          }).concat(alert.extension.builders.map(function(builder) {
            return builder.name;
          })).join('::');
        }
        return null;
      },

      ////////////////////// Bugs ///////////////////////////

      _handleLinkBug: function(evt) {
        this._bugModel = evt.model.alert;
        // TODO(martiniss): make this link be customized per builder
        this.$.fileBugLink.href = "https://crbug.com/new";
        this.$.bugDialog.open();
      },

      _fileBugClicked: function() {
        this._filedBug = true;
      },

      _closeBugDialog: function() {
        this.$.bugDialog.close();
      },

      _saveBug: function() {
        this._sendAnnotation(
          this._keyForAlert(this._bugModel), 'add', {
            bugs: [this.$.bug.value]
          });
      },
    });
  })();
  </script>
</dom-module>
