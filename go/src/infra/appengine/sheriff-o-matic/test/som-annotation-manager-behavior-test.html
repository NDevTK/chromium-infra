<!DOCTYPE html>
<meta charset="utf-8">
<script src="/bower_components/webcomponentsjs/webcomponents.min.js"></script>
<script src="/bower_components/web-component-tester/browser.js"></script>
<link rel="import" href="/bower_components/iron-test-helpers/iron-test-helpers.html">
<link rel="import" href="/elements/som-annotation-manager-behavior.html">

<dom-module id="test-behavior">
  <template>
    <div>
    </div>
  </template>
  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'test-behavior',
        behaviors: [AnnotationManagerBehavior],
        properties: {
          xsrfToken: {
            type: String,
            value: function() { return "xr"; },
          },
          disableAuto: {
            type: Boolean,
            value: function() { return false; },
          },
        }
      });
    })();
  </script>
</dom-module>

<test-fixture id="basic">
  <template>
    <test-behavior></test-behavior>
  </template>
</test-fixture>
<script>
(function() {
  'use strict';
  var element;

  setup(function() {
    element = fixture('basic');
    sinon.stub(window, 'fetch');
  });

  teardown(function() {
    window.fetch.restore();
  });

  suite('local state', function() {
    test('mutateLocalState', function() {
      element.localState = {
        foo: 3
      };
      element.mutateLocalState((state) => {
        assert.deepEqual(state, {
          foo: 3
        });
        return state;
      });
    });

    test('setLocalStateKey', function() {
      element.setLocalStateKey('thing', {
        foo: 5
      });
      assert.deepEqual(element.localState, {
        thing: {
          foo: 5
        },
      });
    });
  });

  suite('network requests', function() {
    test('send fetch all annotation request', function(done) {
      let res = new window.Response(JSON.stringify({
        hi: 3
      }), {
        status: 200,
        headers: {
          'Content-type': 'application/json',
        }
      });

      window.fetch.returns(Promise.resolve(res));

      element.fetchAnnotations();
      flush(() => {
        assert.equal(window.fetch.callCount, 1);
        assert.deepEqual(element._annotationsResp, {hi:3});
        done();
      });
    });

    test('send change annotation request', function(done) {
      let res = new window.Response(JSON.stringify({
        key: "bestkey",
        hi: 3,
      }), {
        status: 200,
        headers: {
          'Content-type': 'application/json',
        }
      });

      window.fetch.returns(Promise.resolve(res));

      let promise = element.sendAnnotation("bestkey", "type", {
        foo: "bar"
      });
      flush(() => {
        assert.equal(window.fetch.callCount, 1);
        let args = window.fetch.firstCall.args;
        assert.equal(args[0], '/api/v1/annotations/bestkey/type');
        let parsed = args[1];
        assert.isDefined(parsed.body);
        parsed.body = JSON.parse(parsed.body);
        assert.deepEqual(parsed, {
          body: {
            xsrf_token: "xr",
            data: {
              foo: "bar"
            }
          },
          method: 'POST',
          credentials: 'include',
        });

        assert.deepEqual(element._annotationsResp, [{key: "bestkey", hi:3}]);
        promise.then((value) => {
          assert.deepEqual(value, {
            key: "bestkey",
            hi: 3,
          });
          done();
        });
      });
    });
  });

  suite('compute annotations', function() {
    var clock;

    setup(function() {
      clock = sinon.useFakeTimers();
    });

    test('compute annotations object correctly', function() {
      let annotations = [{key: 'foo', bugs: ['bar']}];
      assert.deepEqual({
        foo: {
          key: 'foo',
          bugs: ['bar']
        }
      }, element._computeAnnotations(annotations, {}));
    });

    test('compute per item annotation correctly', function() {
      let annotations = {
        foo: {
          key: 'foo',
          snoozeTime: 0,
        },
        bar: {
          key: 'bar',
          bugs: ["bar"],
        },
        baz: {
          key: 'baz',
          opened: true,
        }
      };

      assert.deepEqual(element.computeAnnotation(annotations, {key: 'foo'}), {
          key: 'foo',
          snoozed: false,
          opened: false,
        });

      assert.deepEqual(element.computeAnnotation(annotations, {key: 'baz'}), {
          key: 'baz',
          opened: true,
        });

      annotations.foo.snoozeTime = 200;
      assert.deepEqual(element.computeAnnotation(annotations, {key: 'foo'}), {
          key: 'foo',
          snoozed: true,
          opened: false,
        });

      assert.deepEqual(element.computeAnnotation(annotations, {key: 'bar'}), {
          key: 'bar',
          bugs:['bar'],
          opened: false,
        });
    });
  });


})();
</script>
