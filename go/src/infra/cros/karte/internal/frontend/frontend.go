// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package frontend

import (
	"context"
	"fmt"
	"time"

	"go.chromium.org/luci/common/clock"
	"go.chromium.org/luci/common/logging"
	"go.chromium.org/luci/grpc/prpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	kartepb "infra/cros/karte/api"
	"infra/cros/karte/internal/errors"
	"infra/cros/karte/internal/uuid"
)

// karteFrontend is the implementation of kartepb.KarteServer
// used in the application.
type karteFrontend struct{}

// NewKarteFrontend produces a new Karte frontend.
func NewKarteFrontend() kartepb.KarteServer {
	return &karteFrontend{}
}

// CreateAction creates an action, stores it in datastore, and then returns the just-created action.
func (k *karteFrontend) CreateAction(ctx context.Context, req *kartepb.CreateActionRequest) (*kartepb.Action, error) {
	if req == nil {
		return nil, status.Errorf(codes.InvalidArgument, "create action: request is nil")
	}
	if req.GetAction() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "create action: action is nil")
	}
	if req.GetAction().GetName() != "" {
		return nil, status.Errorf(codes.InvalidArgument, "create action: custom names not supported; names will be generated by the service")
	}
	// Here we use the action create time given to us in the request proto instead of time.Now() so that
	// It is possible to backfill Karte with data from past tasks.
	// We don't trust these timestamps completely (after all, backfilled timestamps are lies), but the UUID suffix
	// should do a good job of guaranteeing uniqueness.
	// Additionally, Karte queries depend on the end_time of the event *as reported by the event*.
	// Events also have an a priori maximum duration,  which means that we can perform a semantically correct query based on the
	// end time using IDs whose lexicographic sort order takes the current timestamp into account.
	name, err := makeID(convertTimestampPtrToTime(req.GetAction().GetCreateTime()))
	if err != nil {
		return nil, errors.Annotate(err, "create action").Err()
	}
	req.Action.Name = name

	logging.Infof(ctx, "Creating action of kind %q", req.GetAction().GetKind())
	actionEntity, err := convertActionToActionEntity(req.GetAction())
	if err != nil {
		logging.Errorf(ctx, "error converting action: %s", err)
		return nil, errors.Annotate(err, "create action").Err()
	}
	if err := PutActionEntities(ctx, actionEntity); err != nil {
		logging.Errorf(ctx, "error writing action: %s", err)
		return nil, errors.Annotate(err, "writing action to datastore").Err()
	}
	return req.GetAction(), nil
}

// CreateObservation creates an observation and then returns the just-created observation.
func (k *karteFrontend) CreateObservation(ctx context.Context, req *kartepb.CreateObservationRequest) (*kartepb.Observation, error) {
	if req == nil {
		return nil, status.Errorf(codes.InvalidArgument, "create observation: request is nil")
	}
	if req.GetObservation() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "create observation: observation is nil")
	}
	if req.GetObservation().GetName() != "" {
		return nil, status.Errorf(codes.InvalidArgument, "create observation: custom names not supported; names will be generated by the service")
	}
	name, err := makeID(clock.Now(ctx))
	if err != nil {
		return nil, errors.Annotate(err, "create-action").Err()
	}
	req.Observation.Name = name

	observationEntity, err := convertObservationToObservationEntity(req.GetObservation())
	if err != nil {
		return nil, errors.Annotate(err, "create observation").Err()
	}
	if err := PutObservationEntities(ctx, observationEntity); err != nil {
		return nil, errors.Annotate(err, "writing action to datastore").Err()
	}
	return req.GetObservation(), nil
}

// ListActions lists the actions that Karte knows about.
func (k *karteFrontend) ListActions(ctx context.Context, req *kartepb.ListActionsRequest) (*kartepb.ListActionsResponse, error) {
	q, err := newActionEntitiesQuery(req.GetPageToken(), req.GetFilter())
	if err != nil {
		return nil, errors.Annotate(err, "list actions").Err()
	}

	es, err := q.Next(ctx, req.GetPageSize())
	if err != nil {
		return nil, errors.Annotate(err, "list actions (page size: %d)", req.GetPageSize()).Err()
	}
	var actions []*kartepb.Action
	for _, e := range es {
		actions = append(actions, e.ConvertToAction())
	}
	return &kartepb.ListActionsResponse{
		Actions:       actions,
		NextPageToken: q.Token,
	}, nil
}

// ListObservations lists the observations that Karte knows about.
func (k *karteFrontend) ListObservations(ctx context.Context, req *kartepb.ListObservationsRequest) (*kartepb.ListObservationsResponse, error) {
	q, err := newObservationEntitiesQuery(req.GetPageToken(), req.GetFilter())
	if err != nil {
		return nil, errors.Annotate(err, "list observations").Err()
	}
	es, err := q.Next(ctx, req.GetPageSize())
	if err != nil {
		return nil, errors.Annotate(err, "list observations (page size: %d)", req.GetPageSize()).Err()
	}
	var observations []*kartepb.Observation
	for _, e := range es {
		observations = append(observations, e.ConvertToObservation())
	}
	return &kartepb.ListObservationsResponse{
		Observations:  observations,
		NextPageToken: q.Token,
	}, nil
}

// UpdateAction updates an action in datastore and creates it if necessary when allow_missing is set.
func (k *karteFrontend) UpdateAction(ctx context.Context, req *kartepb.UpdateActionRequest) (*kartepb.Action, error) {
	reqActionEntity, err := convertActionToActionEntity(req.GetAction())
	if err != nil {
		return nil, errors.Annotate(err, "update action").Err()
	}
	entity, err := UpdateActionEntity(
		ctx,
		reqActionEntity,
		req.GetUpdateMask().GetPaths(),
	)
	return entity.ConvertToAction(), err
}

// InstallServices takes a Karte frontend and exposes it to a LUCI prpc.Server.
func InstallServices(srv *prpc.Server) {
	kartepb.RegisterKarteServer(srv, NewKarteFrontend())
}

// This version number identifies the format used for IDs.
// If you are making an incompatible change, increment the version used here.
// Since the version is the first number in the ID, this means that future ID versions will necessary sort
// after older ID versions.
//
// 001 has the form 001-%021d-%010d-%s
//                  version - unix seconds - nanoseconds since beginning of second - uuid disambiguation suffix.
//
const idSchemeVersion = 1

// MakeID makes an unambiguous ID for a given entity.
func makeID(t time.Time) (string, error) {
	suffix, err := uuid.UUID()
	if err != nil {
		return "", errors.Annotate(err, "make id").Err()
	}
	return makeRawID(t, suffix)
}

// IDFmt describes how to build an ID string.
// Maximum value for an int64 is 9,223,372,036,854,775,807.
// This is 19 bits wide. Use 21 bits for safety.
// A nanosecond is one second * 10^(-9). Therefore, the maximum value
// that the nanosecond part can have is 9 digits long.
// Use 10 for safety.
const idFmt = "%03d-%021d-%010d-%s"

// MakeRawID makes an ID for a given entity by taking a time (the creation or ingestion time, depending on the kind).
// The uuidSuffix is a uuid that will be used as a disambiguation suffix.
func makeRawID(t time.Time, uuidSuffix string) (string, error) {
	if t.IsZero() {
		return "", errors.New("make id: timestamp is zero")
	}
	if uuidSuffix == "" {
		return "", errors.New("make id: uuidSuffix is empty")
	}
	return fmt.Sprintf(
		idFmt,
		idSchemeVersion,
		t.Unix(),
		(t.UnixNano() % (1000 * 1000 * 1000)),
		uuidSuffix,
	), nil
}
