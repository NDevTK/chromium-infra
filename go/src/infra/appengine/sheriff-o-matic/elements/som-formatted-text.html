<dom-module id="som-formatted-text">
  <template>
    <template is="dom-repeat" items="[[_computeTextFragments(text)]]" as="fragment">
      <template is="dom-if" if="[[fragment.link]]"><a href="[[fragment.link]]" target="_blank">[[fragment.linkText]]</a></template>[[fragment.text]]
    </template>
  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'som-formatted-text',

      properties: {
        text: String,
      },

      // To add links to texts without injecting arbitrary HTML, we're
      // splitting the text up into fragments that Polymer iterates through.
      // A text fragment is treated as a link if the link property is set.
      _computeTextFragments(text) {
        if (!text) {
          return [];
        }

        // Regex is bad, but the data is unstructured user input, so missing
        // a few matches is not that bad.
        let emailRegex = /((^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+)@([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$))/;
        let urlRegex = /(https?:\/\/(www\.)?([-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6})\b([-a-zA-Z0-9@:%_\+.~#?&//=]*))/;

        // Commas are included because they are often used to delimit emails.
        let words = text.split(/(\s|,)/);
        let currentFragment = '';
        let result = [];
        for (let i in words) {
          let w = words[i];
          let emailMatch = w.match(emailRegex);
          let urlMatch = w.match(urlRegex);

          if (emailMatch || urlMatch) {
            if (currentFragment !== '') {
              result.push({text: currentFragment});
              currentFragment = '';
            }

            if (emailMatch) {
              result.push({
                // Capture group for the "username" section of the email.
                linkText: emailMatch[2],
                link: 'mailto:' + emailMatch[0], // The whole email.
              });
            } else if (urlMatch) {
              // [3]: Capture group for the domain section of the link.
              // [4]: Capture group for the path. Shorten path if too long.
              let text = urlMatch[3] + this._truncateString(urlMatch[4], 80);
              result.push({
                linkText: text,
                link: urlMatch[1], // The whole link.
              });
            }
          } else {
            currentFragment += w;
          }
        }
        // Add trailing fragment
        if (currentFragment !== '') {
          result.push({text: currentFragment});
        }
        return result;
      },

      _truncateString: function (str, maxLen) {
        if (!str || str.length < maxLen) {
          return str;
        }
        let l = maxLen / 2;
        return str.substr(0, l) + '...' + str.substr(str.length - l);
      },
    });
  })();
  </script>
</dom-module>
