<!-- Copyright (c) 2014 The Chromium Authors. All rights reserved.
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. -->
<!doctype html>
<html>
  <head>
    <title>Commit Queue Status</title>
    <link href='//fonts.googleapis.com/css?family=RobotoDraft:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en' rel='stylesheet' type='text/css'>
    <script type='text/javascript' src='//www.google.com/jsapi'></script>
    <script>
      var PROJECT = '{{ project|safe }}';
      var LENGTH_DATA = {{ length|safe }};
    </script>
    <style type="text/css">
      body {
        font-family: 'RobotoDraft';
      }
      h2 {
        margin-top: 40px;
      }
      .list {
        font-weight: bold;
      }
      li {
        font-weight: normal;
      }
      a {
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <h1>Commit Queue Stats</h1>

    <h2>Times: Single Run</h2>
    <div class="chart" id="attempt-durations-chart"></div>
    <ul class="list" id="attempt-durations-list"></ul>

    <h2>Times: Time in Queue Over All Runs</h2>
    <div class="chart" id="patchset-total-commit-queue-durations-chart"></div>
    <ul class="list" id="patchset-total-commit-queue-durations-list"></ul>

    <h2>Times: Time from Checking "Commit" Box to Complete</h2>
    <div class="chart" id="patchset-total-wall-time-durations-chart"></div>
    <ul class="list" id="patchset-total-wall-time-durations-list"></ul>

    <h2>Commit Queue Length</h2>
    <div class="chart" id="length-chart"></div>

    <script>
      var cqLogURL = '//chromium-cq-status.appspot.com';
      var intervalMinutes = 60;
      var gvisReady = false;
      var chartsToDraw = [];
      var xhrCache = {};
      google.load('visualization', '1.1', {'packages': ['annotationchart']});
      google.setOnLoadCallback(function() {
        gvisReady = true;
        chartsToDraw.forEach(function(args) {
          drawChart.apply(null, args);
        });
      });
      drawChart(LENGTH_DATA, 'length-chart');
      loadNamedStats([
        'attempt-durations',
        'patchset-total-commit-queue-durations',
        'patchset-total-wall-time-durations',
      ], function(namedStats) {
        Object.keys(namedStats).forEach(function(name) {
          var stats = namedStats[name];
          var data = buildChartDataFromStats(stats);
          drawChart(data, name + '-chart', function(chart) {
            chart.addSelectListener(function() {
              var selection = chart.getSelection();
              var listId = name + '-list';
              if (selection.length) {
                var stat = stats[selection[0].row];
                listWorstPatches(stat, listId);
              } else {
                hideWorstPatches(listId);
              }
            });
          });
        });
      });

      function loadNamedStats(names, callback) {
        var namedStats = {};
        names.forEach(function(name) {
          namedStats[name] = [];
        });
        var url =
            cqLogURL + '/stats/query' +
            '?project=' + PROJECT +
            '&interval_minutes=' + intervalMinutes +
            '&names=' + names.join(',') +
            '&count=25';
        loadJSON(url, function(json) {
          json.results.forEach(function(cqStats) {
            cqStats.stats.forEach(function(stat) {
              stat.begin = cqStats.begin;
              stat.key = cqStats.key;
              namedStats[stat.name].push(stat);
            });
          });
          callback(namedStats);
        });
      }

      function loadJSON(url, callback) {
        // Worst patches and Rietveld issue names are likely to be requested
        // multiple times, we cache the JSON requests to avoid network delays on
        // subsequent fetches.
        if (xhrCache[url]) {
          callback(xhrCache[url]);
          return;
        }
        var xhr = new XMLHttpRequest();
        xhr.open('get', url, true);
        xhr.responseType = 'json';
        xhr.onload = function() {
          xhrCache[url] = xhr.response;
          callback(xhr.response);
        };
        xhr.send();
      }

      function buildChartDataFromStats(stats) {
        return {
          cols: [
            {'id': 'timestamp', 'label': 'Time', 'type': 'number'},
            {'id': 'min', 'label': 'Min', 'type': 'number'},
            {'id': 'mean', 'label': 'Mean', 'type': 'number'},
            {'id': 'p50', 'label': '50th', 'type': 'number'},
            {'id': 'p90', 'label': '90th', 'type': 'number'},
            {'id': 'p99', 'label': '99th', 'type': 'number'},
          ],
          rows: stats.map(function(stat) {
            return {
              c: [
                {v: stat.begin + intervalMinutes * 60},
                {v: stat.min / 60},
                {v: stat.mean / 60},
                {v: stat.percentile_50 / 60},
                {v: stat.percentile_90 / 60},
                {v: stat.percentile_99 / 60},
              ],
            };
          }),
        };
      }

      function drawChart(data, id, callback) {
        if (!gvisReady) {
          chartsToDraw.push(arguments);
          return;
        }
        var dataTable = new google.visualization.DataTable(data);
        // Convert POSIX timestamps to localized Date objects.
        var dataView = new google.visualization.DataView(dataTable);
        var columns = Object.keys(data.cols).map(Number);
        columns[0] = {
          label: 'Time',
          type: 'datetime',
          calc: function(table, row) {
            return new Date(table.getValue(row, 0) * 1000);
          },
        };
        dataView.setColumns(columns);
        var chart = new google.visualization.AnnotationChart(
            document.getElementById(id));
        var options = {
          displayAnnotations: true,
        };
        chart.draw(dataView, options);
        if (callback) {
          chart.addSelectListener = function(listener) {
            // This line is obnoxiously long so we wrap it in a method.
            google.visualization.events.addListener(chart, 'select', listener);
          };
          callback(chart);
        }
      };

      function listWorstPatches(stat, listId) {
        var list = document.getElementById(listId);
        list.textContent = 'Loading...';
        var url = cqLogURL + '/stats/highest/' + stat.name + '/' + stat.key;
        loadJSON(url, function(worstItems) {
          list.textContent =
              'Worst patches between ' + new Date(stat.begin * 1000) + ' and ' +
              new Date((stat.begin + intervalMinutes * 60) * 1000) + ':';
          worstItems.forEach(function(item) {
            var li = document.createElement('li');
            var minutes = item[0] / 60;
            li.textContent = minutes.toFixed(2) + ' minutes: ';
            var issue = item[1].issue;
            var patchset = item[1].patchset;
            var link = newLink(
                '//codereview.chromium.org/' + issue + '#' + patchset);
            var url = 'https://codereview.chromium.org/api/' + issue;
            loadJSON(url, function(json) {
              link.textContent = json.subject;
            });
            li.appendChild(link);
            li.appendChild(newElement('span', ' - '));
            li.appendChild(newLink(
                cqLogURL + '/patch-status/' + issue + '/' + patchset,
                '[CQ status]'));
            list.appendChild(li);
          });
        });
      }

      function hideWorstPatches(listId) {
        document.getElementById(listId).textContent = '';
      }

      function newElement(tag, text) {
        var element = document.createElement(tag);
        if (text) {
          element.textContent = text;
        }
        return element;
      }

      function newLink(href, text) {
        var a = newElement('a', text ? text : href);
        a.href = href;
        return a;
      }
    </script>
  </body>
</html>
