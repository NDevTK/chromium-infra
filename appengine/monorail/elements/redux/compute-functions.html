<script>
  (function(window) {
    // Functions to compute commonly reused derived data.
    // TODO(zhangtiff): Consider using Reselect to make this nicer.
    // https://redux.js.org/recipes/computing-derived-data

    const computeFunction = Object.freeze({
      computeIssueType: (labelRefs) => {
        if (!labelRefs) return null;
        const prefix = 'type-';
        const typeLabel = labelRefs.find(
          (l) => (l.label.toLowerCase().startsWith(prefix))
        );
        if (typeLabel) {
          return typeLabel.label.substring(prefix.length);
        }
        return null;
      },
      // values (from issue.fieldValues) is an array with one entry per value.
      // We want to turn this into a map of fieldNames -> values.
      // TODO(zhangtiff): Use Reselect to calculate this so we don't have to
      // recompute it so often.
      computeFieldValueMap: (values) => {
        if (!values) return {};
        return values.reduce((acc, v) => {
          const fieldName = v.fieldRef.fieldName;
          if (!(fieldName in acc)) {
            acc[fieldName] = [v.value];
          } else {
            acc[fieldName].push(v.value);
          }
          return acc;
        }, {});
      },
      // Enum fields in Monorail have their options stored in labels with the
      // field name as the prefix. This gets the values for a specific field
      // given a fieldName.
      computeOptionsForField: (labelDefs, fieldName) => {
        return labelDefs.filter((label) => {
          return label.label.toLowerCase().startsWith(fieldName.toLowerCase());
        }).map((enumLabel) => {
          enumLabel.optionName = enumLabel.label.substring(
            fieldName.length + 1);
          return enumLabel;
        });
      },
      // Filter fieldDefs to get the field defs applicable to a specific issue
      // or approval.
      computeFieldDefs: (fields, issueType, approvalName, isPhaseField) => {
        if (!fields) return [];
        return fields.filter((f) => {
          issueType = issueType || '';
          approvalName = approvalName || '';

          const lookingForApprovalFields = approvalName.length > 0;

          // Skip approval type fields here.
          if (f.fieldRef.type === 'APPROVAL_TYPE') {
            return false;
          }

          // If the fieldDef is a phase field, whether we want it or not is
          // based completely on whether we're looking for a phase.
          if(f.isPhaseField) {
            return isPhaseField;
          }

          // If this fieldDef belongs to only one type, filter out the field if
          // that type isn't the specified issueType.
          if (f.applicableType && issueType.toLowerCase()
              !== f.applicableType.toLowerCase()) {
            return false;
          }

          // Look for approval fieldDefs if we want them.
          if(f.fieldRef && f.fieldRef.approvalName) {
            return lookingForApprovalFields && approvalName.toLowerCase()
                === f.fieldRef.approvalName.toLowerCase();
          }

          return !lookingForApprovalFields;
        });
      },
    });

    window.computeFunction = computeFunction || {};
  })(window);
</script>
