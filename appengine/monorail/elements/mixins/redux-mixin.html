<link rel="import" href="../../bower_components/polymer-redux/polymer-redux.html">
<script src="../../node_modules/redux/dist/redux.js"></script>
<script>
  (function(window) {
    const actionType = {
      UPDATE_ISSUE_REF: 'UPDATE_ISSUE_REF',
      UPDATE_TOKEN: 'UPDATE_TOKEN',
      UPDATE_USER: 'UPDATE_USER',

      FETCH_ISSUE_START: 'FETCH_ISSUE_START',
      FETCH_ISSUE_SUCCESS: 'FETCH_ISSUE_SUCCESS',
      FETCH_ISSUE_FAILURE: 'FETCH_ISSUE_FAILURE',

      UPDATE_APPROVAL_START: 'UPDATE_APPROVAL_START',
      UPDATE_APPROVAL_SUCCESS: 'UPDATE_APPROVAL_SUCCESS',
      UPDATE_APPROVAL_FAILURE: 'UPDATE_APPROVAL_FAILURE',
    };

    const initial = {
      issueId: 0,
      projectName: '',
      issue: {},
      comments: [],
      issueLoaded: false,
      fetchingIssue: false,
      fetchIssueError: null,
      token: null,

      // Assumption: It's okay to prevent the user from sending multiple
      // approval update requests at once, even for different approvals.
      updatingApproval: false,
      updateApprovalError: null,
    };

    // Helpers for the reducers.
    const updateIssueApproval = (issue, approval) => {
      if (!issue.approvalValues) return issue;
      const newApprovals = issue.approvalValues.map((item, i) => {
        if (item.fieldRef.fieldName === approval.fieldRef.fieldName) {
          // PhaseRef isn't populated on the response so we want to make sure
          // it doesn't overwrite the original phaseRef with {}.
          const a = Object.assign({}, approval, {phaseRef: item.phaseRef});
          return a;
        }
        return item;
      });
      return Object.assign({}, issue, {approvalValues: newApprovals});
    }

    const reducer = (state, action) => {
      switch (action.type) {
        case actionType.UPDATE_ISSUE_REF:
          return Object.assign({}, state, {
            issueId: action.issueId || state.issueId,
            projectName: action.projectName || state.projectName,
          });
        case actionType.UPDATE_TOKEN:
          return Object.assign({}, state, {
            token: action.token,
          });
        case actionType.UPDATE_USER:
          return Object.assign({}, state, {
            user: action.user,
          });

        // Request for getting an issue.
        case actionType.FETCH_ISSUE_START:
          return Object.assign({}, state, {
            issue: {},
            comments: [],
            issueLoaded: false,
            fetchIssueError: null,
            fetchingIssue: true,
          });
        case actionType.FETCH_ISSUE_SUCCESS:
          return Object.assign({}, state, {
            issue: action.issue,
            comments: action.comments,
            issueLoaded: true,
            fetchingIssue: false,
          });
        case actionType.FETCH_ISSUE_FAILURE:
          return Object.assign({}, state, {
            fetchIssueError: action.error,
            fetchingIssue: false,
          });

        // Request for updating an approval.
        case actionType.UPDATE_APPROVAL_START:
          return Object.assign({}, state, {
            updatingApproval: true,
          });
        case actionType.UPDATE_APPROVAL_SUCCESS:
          return Object.assign({}, state, {
            issue: updateIssueApproval(state.issue, action.approval),
            updatingApproval: false,
          });
        case actionType.UPDATE_APPROVAL_FAILURE:
          return Object.assign({}, state, {
            updateApprovalError: action.error,
            updatingApproval: false,
          });

        default:
          return state;
      }
    };
    const store = Redux.createStore(reducer, initial);

    ReduxMixin = PolymerRedux(store);

    window.ReduxMixin = ReduxMixin || {};
    window.store = store || {};
    window.actionType = actionType || {};
  })(window);
</script>
