// Code generated by protoc-gen-go. DO NOT EDIT.
// source: swarming.proto

package swarming_v1

import prpc "go.chromium.org/luci/grpc/prpc"

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// BotStatusType is one of the states the bot can be in.
//
// A bot status implies being in this status for a certain amount of time, for
// example a hook running for N seconds, contrary to BotEventType which is about
// an event that doesn't have an inherent duration.
//
// Some values are more important than others. For example if a bot is now
// MISSING but used to be QUARANTINED, the value is still MISSING.
type BotStatusType int32

const (
	// Invalid bot status, do not use.
	BotStatusType_BOT_STATUS_UNSPECIFIED BotStatusType = 0
	// The server detected that the bot is not pinging the server anymore. Unlike
	// other statuses, this value is set after a timeout.
	//
	// Bot.status_msg shall not be set.
	BotStatusType_MISSING BotStatusType = 1
	// Bot was quarantined by the server.
	//
	// Bot.status_msg shall include the server provided rationale.
	BotStatusType_QUARANTINED_BY_SERVER BotStatusType = 2
	// Bot self-reported as unhealthy.
	//
	// What is currently called as 'quarantined' in the old API.
	//
	// Bot.status_msg shall include the bot provided rationale.
	BotStatusType_QUARANTINED_BY_BOT BotStatusType = 3
	// Bot self-reported as unable to run tasks due to externally induced
	// overhead.
	//
	// Examples include:
	// - The temperature of the DUT (Device Under Test) is too high, and the bot
	//   is waiting for cool down
	// - host is doing self-cleaning work out of the bot's control (puppet is
	//   running), etc.
	//
	// Bot.status_msg shall include the bot provided rationale.
	BotStatusType_OVERHEAD_MAINTENANCE_EXTERNAL BotStatusType = 4
	// Bot self-reported as unable to run tasks due to doing internal overhead.
	//
	// Examples include:
	// - Running hooks
	// - Cleaning up or verifying its local cache
	// - Bot is starting for a version upgrade
	//
	// Bot.status_msg shall disambiguate the type of work item done.
	BotStatusType_OVERHEAD_BOT_INTERNAL BotStatusType = 5
	// Bot is down as its host is rebooting and contact was lost.
	//
	// If the bot doesn't contact back soon enough, it will be considered MISSING.
	//
	// Bot.status_msg shall not be set.
	BotStatusType_HOST_REBOOTING BotStatusType = 6
	// Running a task.
	//
	// Bot.status_msg shall not be set.
	BotStatusType_BUSY BotStatusType = 7
	// Bot is 'reserved' for operations outside of normal operations. This can be
	// relevant for SUT (System Under Test).
	//
	// Bot.status_msg shall not be set.
	BotStatusType_RESERVED BotStatusType = 8
	// Bot is healthy and waiting for tasks.
	//
	// Bot.status_msg shall not be set.
	BotStatusType_IDLE BotStatusType = 9
)

var BotStatusType_name = map[int32]string{
	0: "BOT_STATUS_UNSPECIFIED",
	1: "MISSING",
	2: "QUARANTINED_BY_SERVER",
	3: "QUARANTINED_BY_BOT",
	4: "OVERHEAD_MAINTENANCE_EXTERNAL",
	5: "OVERHEAD_BOT_INTERNAL",
	6: "HOST_REBOOTING",
	7: "BUSY",
	8: "RESERVED",
	9: "IDLE",
}

var BotStatusType_value = map[string]int32{
	"BOT_STATUS_UNSPECIFIED":        0,
	"MISSING":                       1,
	"QUARANTINED_BY_SERVER":         2,
	"QUARANTINED_BY_BOT":            3,
	"OVERHEAD_MAINTENANCE_EXTERNAL": 4,
	"OVERHEAD_BOT_INTERNAL":         5,
	"HOST_REBOOTING":                6,
	"BUSY":                          7,
	"RESERVED":                      8,
	"IDLE":                          9,
}

func (x BotStatusType) String() string {
	return proto.EnumName(BotStatusType_name, int32(x))
}

func (BotStatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{0}
}

// BotEventType defines the reason why BotEvent was created.
type BotEventType int32

const (
	// Invalid bot event type, do not use.
	BotEventType_BOT_EVENT_TYPE_UNSPECIFIED BotEventType = 0
	// Bot connected and started a new session.
	//
	// BotEvent.event_msg shall not be set.
	BotEventType_BOT_NEW_SESSION BotEventType = 1
	// Bot had an internal failure to report to the server outside of a task
	// context. This shall send a report to the administrator of the instance and
	// service author.
	//
	// BotEvent.event_msg shall contain the error message.
	BotEventType_BOT_INTERNAL_FAILURE BotEventType = 2
	// Bot had an hook error to report to the server. This shall send a report to
	// the administrator of the instance.
	//
	// BotEvent.event_msg shall contain the error message.
	BotEventType_BOT_HOOK_ERROR BotEventType = 3
	// Bot hook logged information. The bot hooks can log locally to the local log
	// file, which itself can be streamed out of band. For special notifications
	// that are worth notifying the administrator, this event can be used to raise
	// these. Due to the cost of doing an RPC just for this, this should be used
	// sparingly; vs local logging.
	//
	// BotEvent.event_msg shall contain the log entry.
	BotEventType_BOT_HOOK_LOG BotEventType = 4
	// Bot initiated a host reboot. An example is a bot hook requesting to reboot
	// the host after a task failure.
	//
	// BotEvent.event_msg shall contain the reason for rebooting the host, if any.
	BotEventType_BOT_REBOOTING_HOST BotEventType = 5
	// Bot is shutting down. It may be restarting for an update.
	//
	// BotEvent.event_msg shall contain the reason.
	BotEventType_BOT_SHUTDOWN BotEventType = 6
	// The server instructs the bot to stay idle. This is when there is no task
	// pending for this bot. Will only be stored when there are other state
	// changes.
	//
	// BotEvent.event_msg shall not be set.
	BotEventType_INSTRUCT_IDLE BotEventType = 10
	// The server instructs the bot to start a task.
	//
	// BotEvent.event_msg shall not be set. BotEvent.bot.current_task_id shall
	// contain the task ID.
	BotEventType_INSTRUCT_START_TASK BotEventType = 11
	// The server instructs the bot to restart without self-updating. This is to
	// initiate a new bot session.
	//
	// BotEvent.event_msg can be set to the rationale, if any.
	BotEventType_INSTRUCT_RESTART_BOT BotEventType = 12
	// The server instructs the bot to self-update.
	//
	// BotEvent.event_msg shall be set to the version to update to.
	// BotEvent.bot.info.version contains the bot's previous version.
	BotEventType_INSTRUCT_UPDATE_BOT_CODE BotEventType = 13
	// The server instructs the bot to stop its process.
	//
	// BotEvent.event_msg shall not be set. BotEvent.bot.current_task_id shall
	// contain the task ID.
	BotEventType_INSTRUCT_TERMINATE_BOT BotEventType = 14
	// Bot completed a task.
	//
	// BotEvent.event_msg shall not be set. BotEvent.bot.current_task_id shall
	// contain the task ID.
	BotEventType_TASK_COMPLETED BotEventType = 20
	// Bot had an internal failure to report to the server while processing a
	// task. This shall send a report to the administrator of the instance and
	// service author.
	//
	// BotEvent.event_msg shall contain the error message.
	// BotEvent.bot.current_task_id shall contain the task ID.
	BotEventType_TASK_INTERNAL_FAILURE BotEventType = 21
	// Bot is forcibly killing the task.
	//
	// BotEvent.event_msg shall not be set. BotEvent.bot.current_task_id shall
	// contain the task ID.
	BotEventType_TASK_KILLED BotEventType = 22
)

var BotEventType_name = map[int32]string{
	0:  "BOT_EVENT_TYPE_UNSPECIFIED",
	1:  "BOT_NEW_SESSION",
	2:  "BOT_INTERNAL_FAILURE",
	3:  "BOT_HOOK_ERROR",
	4:  "BOT_HOOK_LOG",
	5:  "BOT_REBOOTING_HOST",
	6:  "BOT_SHUTDOWN",
	10: "INSTRUCT_IDLE",
	11: "INSTRUCT_START_TASK",
	12: "INSTRUCT_RESTART_BOT",
	13: "INSTRUCT_UPDATE_BOT_CODE",
	14: "INSTRUCT_TERMINATE_BOT",
	20: "TASK_COMPLETED",
	21: "TASK_INTERNAL_FAILURE",
	22: "TASK_KILLED",
}

var BotEventType_value = map[string]int32{
	"BOT_EVENT_TYPE_UNSPECIFIED": 0,
	"BOT_NEW_SESSION":            1,
	"BOT_INTERNAL_FAILURE":       2,
	"BOT_HOOK_ERROR":             3,
	"BOT_HOOK_LOG":               4,
	"BOT_REBOOTING_HOST":         5,
	"BOT_SHUTDOWN":               6,
	"INSTRUCT_IDLE":              10,
	"INSTRUCT_START_TASK":        11,
	"INSTRUCT_RESTART_BOT":       12,
	"INSTRUCT_UPDATE_BOT_CODE":   13,
	"INSTRUCT_TERMINATE_BOT":     14,
	"TASK_COMPLETED":             20,
	"TASK_INTERNAL_FAILURE":      21,
	"TASK_KILLED":                22,
}

func (x BotEventType) String() string {
	return proto.EnumName(BotEventType_name, int32(x))
}

func (BotEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{1}
}

// TaskStateCategory represents the 5 different categories of task state.
//
// For active state categories (RUNNING_MASK and TRANSIENT_DONE_MASK), it is
// possible to go 'back' to PENDING_MASK category; for example, a task has an
// internal error, and the server reenqueues the task for a second try.
type TaskStateCategory int32

const (
	// Invalid value.
	TaskStateCategory_TASK_STATE_CATEGORY_UNSPECIFIED TaskStateCategory = 0
	// Bit mask for the TaskState inside each category.
	TaskStateCategory_TASK_STATE_MASK TaskStateCategory = 15
	// The task is enqueued and pending bot availability.
	TaskStateCategory_CATEGORY_PENDING TaskStateCategory = 16
	// The task is running.
	TaskStateCategory_CATEGORY_RUNNING TaskStateCategory = 32
	// Transient done states are uncertain states; something ran but the result
	// was inconclusive.
	//
	// They can trigger the Swarming internal retry mechanism. In this case, the
	// "task try" will have this state, but the task summary will become PENDING.
	// In case the task cannot be retried, when idempotent is false, then this
	// becomes a final state.
	TaskStateCategory_CATEGORY_TRANSIENT_DONE TaskStateCategory = 48
	// The task ran, and it is done.
	TaskStateCategory_CATEGORY_EXECUTION_DONE TaskStateCategory = 64
	// The task did not run, and won't.
	TaskStateCategory_CATEGORY_NEVER_RAN_DONE TaskStateCategory = 80
)

var TaskStateCategory_name = map[int32]string{
	0:  "TASK_STATE_CATEGORY_UNSPECIFIED",
	15: "TASK_STATE_MASK",
	16: "CATEGORY_PENDING",
	32: "CATEGORY_RUNNING",
	48: "CATEGORY_TRANSIENT_DONE",
	64: "CATEGORY_EXECUTION_DONE",
	80: "CATEGORY_NEVER_RAN_DONE",
}

var TaskStateCategory_value = map[string]int32{
	"TASK_STATE_CATEGORY_UNSPECIFIED": 0,
	"TASK_STATE_MASK":                 15,
	"CATEGORY_PENDING":                16,
	"CATEGORY_RUNNING":                32,
	"CATEGORY_TRANSIENT_DONE":         48,
	"CATEGORY_EXECUTION_DONE":         64,
	"CATEGORY_NEVER_RAN_DONE":         80,
}

func (x TaskStateCategory) String() string {
	return proto.EnumName(TaskStateCategory_name, int32(x))
}

func (TaskStateCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{2}
}

// TaskState represents the different possible states for a Task.
//
// Each state is in one of the bitmask in TaskStateCategory.
type TaskState int32

const (
	// Invalid task state.
	TaskState_TASK_STATE_INVALID TaskState = 0
	// The task is currently pending.
	//
	// This means that no bot reaped the task yet. It will stay in this state
	// until either a bot reaps the task, or the expiration elapsed or all bots
	// become MISSING, leading to a NO_RESOURCE. The task pending expiration is
	// specified as TaskSlice.expiration, one per task slice.
	//
	// The task may go through multiple pending TaskSlice as they expire or are
	// skipped due to NO_RESOURCE (see definition below). In this situation the
	// task state still stays in PENDING state as long as there's a chance for a
	// bot to reap the task.
	TaskState_PENDING TaskState = 16
	// The task is currently pending, but another previously scheduled task was
	// identified to be deduped against, but the previously scheduled task hasn't
	// completed yet.
	//
	// In this case, the task may go back into PENDING if the previous identical
	// task failed, or immediately into DEDUPED if it succeeded.
	TaskState_PENDING_DEDUPING TaskState = 17
	// The task is currently running.
	//
	// For new tasks, this is only the actual tasks runtime. For old tasks, this
	// includes RUNNING_OVERHEAD_START and RUNNING_OVERHEAD_END.
	TaskState_RUNNING TaskState = 32
	// The task is assigned to a bot. The bot is fetching input files and setting
	// up the runtime environment.
	TaskState_RUNNING_OVERHEAD_SETUP TaskState = 33
	// Task completed and result metadata is available. Outputs and other
	// associated logs are still being uploaded and the environment is being
	// teared down.
	//
	// A client that only needs the exit code may chose to stop waiting for the
	// task, as the task will end with COMPLETED, unless there's a failure during
	// outputs upload, which would result in INTERNAL_FAILURE.
	TaskState_RUNNING_OVERHEAD_TEARDOWN TaskState = 34
	// The task is being forcibly terminated. This can be due to either a kill
	// request, preemption or time out.
	//
	// See
	// https://chromium.googlesource.com/infra/luci/luci-py.git/+/master/appengine/swarming/doc/Bot.md#graceful-termination_aka-the-sigterm-and-sigkill-dance
	TaskState_TERMINATING TaskState = 35
	// Task completed, result metadata and task outputs are available. There's
	// still some overhead being finished like attaching relevant bot logs to the
	// task.
	//
	// The client can return right away unless infrastructure issue debugging is
	// needed.
	TaskState_COMPLETING TaskState = 47
	// The task ran but the bot had an internal failure, unrelated to the task
	// itself. It can be due to disk or network I/O issues.
	TaskState_INTERNAL_FAILURE TaskState = 48
	// The task ran and completed normally, but returned an exit code that was
	// provided in the TaskProperties as signaling an hardware failure of the DUT
	// (Device Under Test).
	//
	// As such, the task may need to be retried.
	TaskState_DUT_FAILURE TaskState = 49
	// The task started but the bot failed to keep the connection to the server
	// alive. This can be due to the bot's host crashing, or network connectivity
	// issues.
	TaskState_BOT_DISAPPEARED TaskState = 50
	// The task ran but was killed by the client or an external scheduler in a way
	// that it should still be retried as another task try.
	//
	// This can happen via the external scheduler or an API yet to be defined. The
	// rationale is to kill slow running low priority task, without disrupting the
	// client and simply postponing the task for later.
	TaskState_PREEMPTED TaskState = 51
	// The task ran and completed normally. The task process exit code may be 0 or
	// another value.
	//
	// This value is also used when the task is deduped against a previous task.
	TaskState_COMPLETED TaskState = 64
	// The task ran for longer than the allowed time in
	// TaskProperties.execution_timeout_secs.
	//
	// This means the bot forcefully killed the task process as described in the
	// graceful termination dance in the documentation.
	TaskState_TIMED_OUT TaskState = 65
	// The task timed out due to not sending updates to stdout or stderr within
	// the period specified in TaskProperties.io_timeout_secs.
	//
	// This means the bot forcefully killed the task process as described in the
	// graceful termination dance in the documentation.
	TaskState_TIMED_OUT_SILENCE TaskState = 66
	// The task ran but was manually killed via the 'cancel' API.
	//
	// This means the bot forcefully killed the task process as described in the
	// graceful termination dance in the documentation.
	TaskState_KILLED TaskState = 67
	// The task didn't have to run, because a previous task had results. It is
	// functionally equivalent to COMPLETED, except that previous results were
	// returned as-is.
	TaskState_DEDUPED TaskState = 80
	// The task is not pending anymore; it never ran due to lack of capacity.
	//
	// This means that other higher priority tasks ran instead and that not enough
	// bots were available to run this task for TaskSlice.expiration.
	TaskState_EXPIRED TaskState = 81
	// The task never ran, and was manually cancelled via the 'cancel' API before
	// it was reaped.
	TaskState_CANCELED TaskState = 82
	// The task was never set to PENDING and was immediately refused, as the
	// server determined that there is no bot capacity to run this task. This
	// happens because no bot exposes a superset of the requested task dimensions.
	//
	// There can be a situation where a task goes from PENDING to NO_RESOURCE if
	// capacity (bots) is removed.
	//
	// Set TaskSlice.wait_for_capacity to True to force the server to keep the
	// task slice pending even in this case. Generally speaking, the task will
	// eventually switch to EXPIRED, as there's no bot to run it. That said, there
	// are situations where it is known that in some not-too-distant future a wild
	// bot will appear that will be able to run this task.
	TaskState_NO_RESOURCE TaskState = 83
	// The task was valid but was denied due to a temporary capacity surcharge.
	// The user should try again after a delay, or surface the lack of capacity to
	// the user.
	TaskState_LOAD_SHED TaskState = 84
	// The task is valid but was denied due to insufficient quota.
	TaskState_RESOURCE_EXHAUSTED TaskState = 85
)

var TaskState_name = map[int32]string{
	0:  "TASK_STATE_INVALID",
	16: "PENDING",
	17: "PENDING_DEDUPING",
	32: "RUNNING",
	33: "RUNNING_OVERHEAD_SETUP",
	34: "RUNNING_OVERHEAD_TEARDOWN",
	35: "TERMINATING",
	47: "COMPLETING",
	48: "INTERNAL_FAILURE",
	49: "DUT_FAILURE",
	50: "BOT_DISAPPEARED",
	51: "PREEMPTED",
	64: "COMPLETED",
	65: "TIMED_OUT",
	66: "TIMED_OUT_SILENCE",
	67: "KILLED",
	80: "DEDUPED",
	81: "EXPIRED",
	82: "CANCELED",
	83: "NO_RESOURCE",
	84: "LOAD_SHED",
	85: "RESOURCE_EXHAUSTED",
}

var TaskState_value = map[string]int32{
	"TASK_STATE_INVALID":        0,
	"PENDING":                   16,
	"PENDING_DEDUPING":          17,
	"RUNNING":                   32,
	"RUNNING_OVERHEAD_SETUP":    33,
	"RUNNING_OVERHEAD_TEARDOWN": 34,
	"TERMINATING":               35,
	"COMPLETING":                47,
	"INTERNAL_FAILURE":          48,
	"DUT_FAILURE":               49,
	"BOT_DISAPPEARED":           50,
	"PREEMPTED":                 51,
	"COMPLETED":                 64,
	"TIMED_OUT":                 65,
	"TIMED_OUT_SILENCE":         66,
	"KILLED":                    67,
	"DEDUPED":                   80,
	"EXPIRED":                   81,
	"CANCELED":                  82,
	"NO_RESOURCE":               83,
	"LOAD_SHED":                 84,
	"RESOURCE_EXHAUSTED":        85,
}

func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}

func (TaskState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{3}
}

// Request for BotAPI.Events.
type BotEventsRequest struct {
	// Required. Bot ID to retrieve results from.
	BotId string `protobuf:"bytes,1,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	// Optional. Use this field to specify the maximum number of results to be
	// returned by the server.
	//
	// The server may further constrain the maximum number of results returned in
	// a single page. If the page_size is 0, the server will decide the number of
	// results to be returned.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Optional. Use this field to request a specific page of the list results,
	// following a previous call.
	//
	// When specified, page_size, start_time and end_time must match exactly the
	// previous call's argument.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Optional. Earliest time to return bot event. Inclusive.
	//
	// If not specified, pagination is done until all events are returned.
	StartTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Optional. Most recent time to return bot event. Exclusive.
	//
	// If not specified, defaults to the current time.
	EndTime              *timestamp.Timestamp `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *BotEventsRequest) Reset()         { *m = BotEventsRequest{} }
func (m *BotEventsRequest) String() string { return proto.CompactTextString(m) }
func (*BotEventsRequest) ProtoMessage()    {}
func (*BotEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{0}
}

func (m *BotEventsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BotEventsRequest.Unmarshal(m, b)
}
func (m *BotEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BotEventsRequest.Marshal(b, m, deterministic)
}
func (m *BotEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotEventsRequest.Merge(m, src)
}
func (m *BotEventsRequest) XXX_Size() int {
	return xxx_messageInfo_BotEventsRequest.Size(m)
}
func (m *BotEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BotEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BotEventsRequest proto.InternalMessageInfo

func (m *BotEventsRequest) GetBotId() string {
	if m != nil {
		return m.BotId
	}
	return ""
}

func (m *BotEventsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *BotEventsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *BotEventsRequest) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *BotEventsRequest) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// Response of BotAPI.Events.
type BotEventsResponse struct {
	// Events are in reverse chronological order, most recents first and going
	// down to older events.
	Events []*BotEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	// This field represents the pagination token to retrieve the next page of
	// results. If the value is "", it means no further results for the request.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BotEventsResponse) Reset()         { *m = BotEventsResponse{} }
func (m *BotEventsResponse) String() string { return proto.CompactTextString(m) }
func (*BotEventsResponse) ProtoMessage()    {}
func (*BotEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{1}
}

func (m *BotEventsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BotEventsResponse.Unmarshal(m, b)
}
func (m *BotEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BotEventsResponse.Marshal(b, m, deterministic)
}
func (m *BotEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotEventsResponse.Merge(m, src)
}
func (m *BotEventsResponse) XXX_Size() int {
	return xxx_messageInfo_BotEventsResponse.Size(m)
}
func (m *BotEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BotEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BotEventsResponse proto.InternalMessageInfo

func (m *BotEventsResponse) GetEvents() []*BotEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *BotEventsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Represents a mapping of string to a list of strings.
//
// The same as a map<key, repeated values>, except that the encoding is
// deterministic.
//
// If the StringListPair is itself repeated inside another message, the list
// must be sorted by key and the keys must be unique.
type StringListPair struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// All the values for this key. values must be sorted. Human readable.
	//
	// This string should make sense to a user in the context of 'key'.
	Values               []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringListPair) Reset()         { *m = StringListPair{} }
func (m *StringListPair) String() string { return proto.CompactTextString(m) }
func (*StringListPair) ProtoMessage()    {}
func (*StringListPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{2}
}

func (m *StringListPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StringListPair.Unmarshal(m, b)
}
func (m *StringListPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StringListPair.Marshal(b, m, deterministic)
}
func (m *StringListPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringListPair.Merge(m, src)
}
func (m *StringListPair) XXX_Size() int {
	return xxx_messageInfo_StringListPair.Size(m)
}
func (m *StringListPair) XXX_DiscardUnknown() {
	xxx_messageInfo_StringListPair.DiscardUnknown(m)
}

var xxx_messageInfo_StringListPair proto.InternalMessageInfo

func (m *StringListPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringListPair) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// Bot describes a Swarming bot.
//
// Because a Swarming bot is a single execution unit unlike RBE, it doesn't have
// a concept of owned device at the moment. This may change later.
type Bot struct {
	// Bot ID. It must be unique accross the Swarming fleet. Generally based on
	// the hostname where the bot runs, but that's not a requirement. Must be
	// predefined in bots.cfg.
	//
	// This value is also included in dimensions for the key 'id'.
	BotId string `protobuf:"bytes,1,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	// Bot session ID. An opaque value.
	//
	// There is one bot session ID per bot process ID on the host. When the bot
	// self-upgrades, it creates a new bot session ID.
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Pools that this bot belongs to. Normally assigned via bots.cfg. The
	// pools must be defined in pools.cfg.
	//
	// Normally a bot shall belong to a single pool, but belonging to multiple
	// pool is allowed. This is generally helpful for transitioning bots.
	//
	// This value is also included in dimensions for the key 'pool'.
	Pools []string `protobuf:"bytes,3,rep,name=pools,proto3" json:"pools,omitempty"`
	// Current bot status. A bot status is a state in which the bot is for a
	// certain amount of time.
	Status BotStatusType `protobuf:"varint,4,opt,name=status,proto3,enum=swarming.v1.BotStatusType" json:"status,omitempty"`
	// Supplemental information to describe the bot status. Human readable.
	//
	// See BotStatusType for the meaning of this string for each status.
	StatusMsg string `protobuf:"bytes,5,opt,name=status_msg,json=statusMsg,proto3" json:"status_msg,omitempty"`
	// Current task being handled by the bot, if there is one.
	//
	// In Swarming, only a single task can be assigned to a bot at any given time.
	CurrentTaskId string `protobuf:"bytes,6,opt,name=current_task_id,json=currentTaskId,proto3" json:"current_task_id,omitempty"`
	// Bot reported dimensions. dimensions is a {key: [values]} dictionary. This
	// can be used to declare the properties of the host or for the DUT (Device
	// Under Test) under control. This is used for task selection.
	//
	// In RBE, this is called Property. The difference is that RBE's Property is a
	// string:string flat dictionary, it doesn't allow repeated values.
	//
	// https://chromium.googlesource.com/infra/luci/luci-py.git/+/master/appengine/swarming/doc/Detailed-Design.md#bot-dimensions
	//
	// dimensions MUST be sorted by keys, and each values list must be sorted.
	// Each dimension key must be unique.
	//
	// The values are effectively an OR, a task may match any of the value.
	//
	// Human readable.
	Dimensions []*StringListPair `protobuf:"bytes,7,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
	// Bot reported informational state. This can be used to describe the host,
	// the bot itself and the DUT (Device Under Test) under control as applicable.
	//
	// This is NOT used for task selection.
	Info                 *BotInfo `protobuf:"bytes,8,opt,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bot) Reset()         { *m = Bot{} }
func (m *Bot) String() string { return proto.CompactTextString(m) }
func (*Bot) ProtoMessage()    {}
func (*Bot) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{3}
}

func (m *Bot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Bot.Unmarshal(m, b)
}
func (m *Bot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Bot.Marshal(b, m, deterministic)
}
func (m *Bot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bot.Merge(m, src)
}
func (m *Bot) XXX_Size() int {
	return xxx_messageInfo_Bot.Size(m)
}
func (m *Bot) XXX_DiscardUnknown() {
	xxx_messageInfo_Bot.DiscardUnknown(m)
}

var xxx_messageInfo_Bot proto.InternalMessageInfo

func (m *Bot) GetBotId() string {
	if m != nil {
		return m.BotId
	}
	return ""
}

func (m *Bot) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Bot) GetPools() []string {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *Bot) GetStatus() BotStatusType {
	if m != nil {
		return m.Status
	}
	return BotStatusType_BOT_STATUS_UNSPECIFIED
}

func (m *Bot) GetStatusMsg() string {
	if m != nil {
		return m.StatusMsg
	}
	return ""
}

func (m *Bot) GetCurrentTaskId() string {
	if m != nil {
		return m.CurrentTaskId
	}
	return ""
}

func (m *Bot) GetDimensions() []*StringListPair {
	if m != nil {
		return m.Dimensions
	}
	return nil
}

func (m *Bot) GetInfo() *BotInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// Bot reported informational state. This can be used to describe the host,
// the bot itself and the DUT (Device Under Test) under control as applicable.
//
// This is NOT used for task selection.
type BotInfo struct {
	// raw contains the current free form json data. This will eventually be
	// subsumed by structured data below.
	Raw *_struct.Struct `protobuf:"bytes,1,opt,name=raw,proto3" json:"raw,omitempty"`
	// Bot's version. An opaque value.
	//
	// This value is Swarming instance and configuration dependent. Bot are
	// updated through the process described at
	// https://chromium.googlesource.com/infra/luci/luci-py.git/+/master/appengine/swarming/doc/Bot.md#update
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// External IP address as visible by the server. Can be either IPv4 or IPv6.
	// This could be a NAT'ing router external IP.
	ExternalIp string `protobuf:"bytes,3,opt,name=external_ip,json=externalIp,proto3" json:"external_ip,omitempty"`
	// Authentication identity that the bot identified as. An opaque value.
	AuthenticatedAs string `protobuf:"bytes,4,opt,name=authenticated_as,json=authenticatedAs,proto3" json:"authenticated_as,omitempty"`
	// State of the content addressed cache on the bot. This is used for inputs
	// files.
	CasStats *CASStats `protobuf:"bytes,5,opt,name=cas_stats,json=casStats,proto3" json:"cas_stats,omitempty"`
	// State of the named caches (used by incremental tasks) on the bot. This is
	// used for task that benefits from incrementality, like builds.
	//
	// Should be sorted by name.
	NamedCachesStats []*NameCacheStats `protobuf:"bytes,6,rep,name=named_caches_stats,json=namedCachesStats,proto3" json:"named_caches_stats,omitempty"`
	// State of the CIPD packages cache on the bot. This is use for installable,
	// versioned packages.
	//
	// Should be sorted by package name, then version.
	CipdPackagesCacheStats []*CIPDPackageCacheStats `protobuf:"bytes,7,rep,name=cipd_packages_cache_stats,json=cipdPackagesCacheStats,proto3" json:"cipd_packages_cache_stats,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                 `json:"-"`
	XXX_unrecognized       []byte                   `json:"-"`
	XXX_sizecache          int32                    `json:"-"`
}

func (m *BotInfo) Reset()         { *m = BotInfo{} }
func (m *BotInfo) String() string { return proto.CompactTextString(m) }
func (*BotInfo) ProtoMessage()    {}
func (*BotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{4}
}

func (m *BotInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BotInfo.Unmarshal(m, b)
}
func (m *BotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BotInfo.Marshal(b, m, deterministic)
}
func (m *BotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotInfo.Merge(m, src)
}
func (m *BotInfo) XXX_Size() int {
	return xxx_messageInfo_BotInfo.Size(m)
}
func (m *BotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BotInfo proto.InternalMessageInfo

func (m *BotInfo) GetRaw() *_struct.Struct {
	if m != nil {
		return m.Raw
	}
	return nil
}

func (m *BotInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BotInfo) GetExternalIp() string {
	if m != nil {
		return m.ExternalIp
	}
	return ""
}

func (m *BotInfo) GetAuthenticatedAs() string {
	if m != nil {
		return m.AuthenticatedAs
	}
	return ""
}

func (m *BotInfo) GetCasStats() *CASStats {
	if m != nil {
		return m.CasStats
	}
	return nil
}

func (m *BotInfo) GetNamedCachesStats() []*NameCacheStats {
	if m != nil {
		return m.NamedCachesStats
	}
	return nil
}

func (m *BotInfo) GetCipdPackagesCacheStats() []*CIPDPackageCacheStats {
	if m != nil {
		return m.CipdPackagesCacheStats
	}
	return nil
}

// Bot local content addressed cache information.
type CASStats struct {
	NumberItems          int64                `protobuf:"varint,1,opt,name=number_items,json=numberItems,proto3" json:"number_items,omitempty"`
	Size                 int64                `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	OldestTime           *timestamp.Timestamp `protobuf:"bytes,3,opt,name=oldest_time,json=oldestTime,proto3" json:"oldest_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CASStats) Reset()         { *m = CASStats{} }
func (m *CASStats) String() string { return proto.CompactTextString(m) }
func (*CASStats) ProtoMessage()    {}
func (*CASStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{5}
}

func (m *CASStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CASStats.Unmarshal(m, b)
}
func (m *CASStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CASStats.Marshal(b, m, deterministic)
}
func (m *CASStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CASStats.Merge(m, src)
}
func (m *CASStats) XXX_Size() int {
	return xxx_messageInfo_CASStats.Size(m)
}
func (m *CASStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CASStats.DiscardUnknown(m)
}

var xxx_messageInfo_CASStats proto.InternalMessageInfo

func (m *CASStats) GetNumberItems() int64 {
	if m != nil {
		return m.NumberItems
	}
	return 0
}

func (m *CASStats) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CASStats) GetOldestTime() *timestamp.Timestamp {
	if m != nil {
		return m.OldestTime
	}
	return nil
}

// Bot local named cache information.
type NameCacheStats struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Size                 int64                `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	LastUseTime          *timestamp.Timestamp `protobuf:"bytes,3,opt,name=last_use_time,json=lastUseTime,proto3" json:"last_use_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NameCacheStats) Reset()         { *m = NameCacheStats{} }
func (m *NameCacheStats) String() string { return proto.CompactTextString(m) }
func (*NameCacheStats) ProtoMessage()    {}
func (*NameCacheStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{6}
}

func (m *NameCacheStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NameCacheStats.Unmarshal(m, b)
}
func (m *NameCacheStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NameCacheStats.Marshal(b, m, deterministic)
}
func (m *NameCacheStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameCacheStats.Merge(m, src)
}
func (m *NameCacheStats) XXX_Size() int {
	return xxx_messageInfo_NameCacheStats.Size(m)
}
func (m *NameCacheStats) XXX_DiscardUnknown() {
	xxx_messageInfo_NameCacheStats.DiscardUnknown(m)
}

var xxx_messageInfo_NameCacheStats proto.InternalMessageInfo

func (m *NameCacheStats) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NameCacheStats) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *NameCacheStats) GetLastUseTime() *timestamp.Timestamp {
	if m != nil {
		return m.LastUseTime
	}
	return nil
}

// Bot local CIPD package cache information.
type CIPDPackageCacheStats struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version              string               `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Size                 int64                `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	LastUseTime          *timestamp.Timestamp `protobuf:"bytes,4,opt,name=last_use_time,json=lastUseTime,proto3" json:"last_use_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *CIPDPackageCacheStats) Reset()         { *m = CIPDPackageCacheStats{} }
func (m *CIPDPackageCacheStats) String() string { return proto.CompactTextString(m) }
func (*CIPDPackageCacheStats) ProtoMessage()    {}
func (*CIPDPackageCacheStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{7}
}

func (m *CIPDPackageCacheStats) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CIPDPackageCacheStats.Unmarshal(m, b)
}
func (m *CIPDPackageCacheStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CIPDPackageCacheStats.Marshal(b, m, deterministic)
}
func (m *CIPDPackageCacheStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CIPDPackageCacheStats.Merge(m, src)
}
func (m *CIPDPackageCacheStats) XXX_Size() int {
	return xxx_messageInfo_CIPDPackageCacheStats.Size(m)
}
func (m *CIPDPackageCacheStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CIPDPackageCacheStats.DiscardUnknown(m)
}

var xxx_messageInfo_CIPDPackageCacheStats proto.InternalMessageInfo

func (m *CIPDPackageCacheStats) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CIPDPackageCacheStats) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CIPDPackageCacheStats) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CIPDPackageCacheStats) GetLastUseTime() *timestamp.Timestamp {
	if m != nil {
		return m.LastUseTime
	}
	return nil
}

// BotEvent represents an event on the bot.
//
// This message is used both in the API and as a BigQuery table description for
// the table 'bot_events' in dataset 'swarming'.
type BotEvent struct {
	EventTime *timestamp.Timestamp `protobuf:"bytes,1,opt,name=event_time,json=eventTime,proto3" json:"event_time,omitempty"`
	// Snapshot of the Bot that had this event.
	//
	// Eventually we'd want to only snapshot the difference from the previous
	// event, but this would make the SQL queries much more complicated.
	Bot *Bot `protobuf:"bytes,2,opt,name=bot,proto3" json:"bot,omitempty"`
	// Type of state change (event) that trigger this message.
	Event BotEventType `protobuf:"varint,3,opt,name=event,proto3,enum=swarming.v1.BotEventType" json:"event,omitempty"`
	// Supplementation information to describe the bot event. Human readable.
	//
	// See BotEventType for the meaning of this string for each status.
	EventMsg             string   `protobuf:"bytes,4,opt,name=event_msg,json=eventMsg,proto3" json:"event_msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BotEvent) Reset()         { *m = BotEvent{} }
func (m *BotEvent) String() string { return proto.CompactTextString(m) }
func (*BotEvent) ProtoMessage()    {}
func (*BotEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_da139cd6eb39e2be, []int{8}
}

func (m *BotEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BotEvent.Unmarshal(m, b)
}
func (m *BotEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BotEvent.Marshal(b, m, deterministic)
}
func (m *BotEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotEvent.Merge(m, src)
}
func (m *BotEvent) XXX_Size() int {
	return xxx_messageInfo_BotEvent.Size(m)
}
func (m *BotEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BotEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BotEvent proto.InternalMessageInfo

func (m *BotEvent) GetEventTime() *timestamp.Timestamp {
	if m != nil {
		return m.EventTime
	}
	return nil
}

func (m *BotEvent) GetBot() *Bot {
	if m != nil {
		return m.Bot
	}
	return nil
}

func (m *BotEvent) GetEvent() BotEventType {
	if m != nil {
		return m.Event
	}
	return BotEventType_BOT_EVENT_TYPE_UNSPECIFIED
}

func (m *BotEvent) GetEventMsg() string {
	if m != nil {
		return m.EventMsg
	}
	return ""
}

func init() {
	proto.RegisterEnum("swarming.v1.BotStatusType", BotStatusType_name, BotStatusType_value)
	proto.RegisterEnum("swarming.v1.BotEventType", BotEventType_name, BotEventType_value)
	proto.RegisterEnum("swarming.v1.TaskStateCategory", TaskStateCategory_name, TaskStateCategory_value)
	proto.RegisterEnum("swarming.v1.TaskState", TaskState_name, TaskState_value)
	proto.RegisterType((*BotEventsRequest)(nil), "swarming.v1.BotEventsRequest")
	proto.RegisterType((*BotEventsResponse)(nil), "swarming.v1.BotEventsResponse")
	proto.RegisterType((*StringListPair)(nil), "swarming.v1.StringListPair")
	proto.RegisterType((*Bot)(nil), "swarming.v1.Bot")
	proto.RegisterType((*BotInfo)(nil), "swarming.v1.BotInfo")
	proto.RegisterType((*CASStats)(nil), "swarming.v1.CASStats")
	proto.RegisterType((*NameCacheStats)(nil), "swarming.v1.NameCacheStats")
	proto.RegisterType((*CIPDPackageCacheStats)(nil), "swarming.v1.CIPDPackageCacheStats")
	proto.RegisterType((*BotEvent)(nil), "swarming.v1.BotEvent")
}

func init() { proto.RegisterFile("swarming.proto", fileDescriptor_da139cd6eb39e2be) }

var fileDescriptor_da139cd6eb39e2be = []byte{
	// 1475 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xc1, 0x72, 0x1b, 0xc7,
	0x11, 0x35, 0x00, 0x12, 0x04, 0x1a, 0x24, 0x38, 0x1c, 0x93, 0x14, 0x04, 0x99, 0x16, 0x05, 0x57,
	0xa5, 0x68, 0x55, 0x85, 0xb2, 0xe1, 0xca, 0x21, 0x71, 0x55, 0xca, 0x0b, 0xec, 0x58, 0xdc, 0x12,
	0xb0, 0xbb, 0x9e, 0x9d, 0xa5, 0xc9, 0x43, 0x6a, 0x6a, 0x09, 0x8c, 0x60, 0x84, 0xc4, 0x2e, 0x82,
	0x59, 0xd0, 0x92, 0x0e, 0xf9, 0x8f, 0x54, 0x3e, 0x23, 0x87, 0xfc, 0x46, 0x6e, 0x39, 0xe6, 0x0b,
	0x72, 0xcf, 0x31, 0xd5, 0xb3, 0x0b, 0x08, 0x20, 0xa9, 0x28, 0xbe, 0x6d, 0xbf, 0xee, 0xe9, 0x79,
	0xfd, 0xba, 0xa7, 0x01, 0xa8, 0xeb, 0x9f, 0xa3, 0xd9, 0x64, 0x1c, 0x8f, 0x4e, 0xa7, 0xb3, 0x24,
	0x4d, 0x68, 0x6d, 0x69, 0xdf, 0x7e, 0xdd, 0xfc, 0x6c, 0x94, 0x24, 0xa3, 0x1b, 0xf5, 0xc2, 0xb8,
	0xae, 0xe6, 0xaf, 0x5f, 0xe8, 0x74, 0x36, 0x1f, 0xa4, 0x59, 0x68, 0xf3, 0xe9, 0x5d, 0x6f, 0x3a,
	0x9e, 0x28, 0x9d, 0x46, 0x93, 0x69, 0x16, 0xd0, 0xfa, 0x67, 0x01, 0x48, 0x27, 0x49, 0xd9, 0xad,
	0x8a, 0x53, 0xcd, 0xd5, 0x9f, 0xe6, 0x4a, 0xa7, 0xf4, 0x00, 0xca, 0x57, 0x49, 0x2a, 0xc7, 0xc3,
	0x46, 0xe1, 0xb8, 0x70, 0x52, 0xe5, 0x9b, 0x57, 0x49, 0xea, 0x0c, 0xe9, 0x13, 0xa8, 0x4e, 0xa3,
	0x91, 0x92, 0x7a, 0xfc, 0x4e, 0x35, 0x8a, 0xc7, 0x85, 0x93, 0x4d, 0x5e, 0x41, 0x20, 0x18, 0xbf,
	0x53, 0xf4, 0x08, 0xc0, 0x38, 0xd3, 0xe4, 0x5a, 0xc5, 0x8d, 0x92, 0x39, 0x67, 0xc2, 0x05, 0x02,
	0xf4, 0xb7, 0x00, 0x3a, 0x8d, 0x66, 0xa9, 0x44, 0x02, 0x8d, 0x8d, 0xe3, 0xc2, 0x49, 0xad, 0xdd,
	0x3c, 0xcd, 0xd8, 0x9d, 0x2e, 0xd8, 0x9d, 0x8a, 0x05, 0x3b, 0x5e, 0x35, 0xd1, 0x68, 0xd3, 0xdf,
	0x40, 0x45, 0xc5, 0xc3, 0xec, 0xe0, 0xe6, 0x47, 0x0f, 0x6e, 0xa9, 0x78, 0x88, 0x56, 0xeb, 0x8f,
	0xb0, 0xb7, 0x52, 0x98, 0x9e, 0x26, 0xb1, 0x56, 0xf4, 0xd7, 0x50, 0x56, 0x06, 0x69, 0x14, 0x8e,
	0x4b, 0x27, 0xb5, 0xf6, 0xc1, 0xe9, 0x8a, 0x96, 0xa7, 0x8b, 0x78, 0x9e, 0x07, 0xd1, 0x5f, 0xc1,
	0x6e, 0xac, 0xde, 0xa4, 0x72, 0xa5, 0xb2, 0xa2, 0xa9, 0x6c, 0x07, 0x61, 0x7f, 0x51, 0x5d, 0xeb,
	0x77, 0x50, 0x0f, 0xd2, 0xd9, 0x38, 0x1e, 0xf5, 0xc6, 0x3a, 0xf5, 0xa3, 0xf1, 0x8c, 0x12, 0x28,
	0x5d, 0xab, 0xb7, 0xb9, 0x7e, 0xf8, 0x49, 0x0f, 0xa1, 0x7c, 0x1b, 0xdd, 0xcc, 0x95, 0x6e, 0x14,
	0x8f, 0x4b, 0x27, 0x55, 0x9e, 0x5b, 0xad, 0xbf, 0x15, 0xa1, 0xd4, 0x49, 0x3e, 0x28, 0xfa, 0x11,
	0x80, 0x56, 0x5a, 0x8f, 0x93, 0x18, 0x5d, 0xd9, 0xed, 0xd5, 0x1c, 0x71, 0x86, 0x74, 0x1f, 0x36,
	0xa7, 0x49, 0x72, 0xa3, 0x1b, 0x25, 0x93, 0x34, 0x33, 0x68, 0x1b, 0xca, 0x3a, 0x8d, 0xd2, 0xb9,
	0x36, 0x4a, 0xd7, 0xdb, 0xcd, 0xbb, 0x65, 0x06, 0xc6, 0x2b, 0xde, 0x4e, 0x15, 0xcf, 0x23, 0xcd,
	0x45, 0xe6, 0x4b, 0x4e, 0xf4, 0xc8, 0x08, 0x5d, 0x35, 0x5d, 0x48, 0xe7, 0xba, 0xaf, 0x47, 0x28,
	0xc5, 0x60, 0x3e, 0x9b, 0xa9, 0x38, 0x95, 0x69, 0xa4, 0xaf, 0x91, 0x4c, 0x39, 0x93, 0x22, 0x87,
	0x45, 0xa4, 0xaf, 0x9d, 0x21, 0xfd, 0x16, 0x60, 0x38, 0x9e, 0xa8, 0x18, 0xf9, 0xe9, 0xc6, 0x96,
	0x51, 0xf9, 0xc9, 0xda, 0xf5, 0xeb, 0x4a, 0xf1, 0x95, 0x70, 0x7a, 0x02, 0x1b, 0xe3, 0xf8, 0x75,
	0xd2, 0xa8, 0x98, 0x36, 0xef, 0xdf, 0x65, 0xed, 0xc4, 0xaf, 0x13, 0x6e, 0x22, 0x5a, 0xff, 0x29,
	0xc2, 0x56, 0x8e, 0xd0, 0x2f, 0xa1, 0x34, 0x8b, 0x7e, 0x36, 0xb2, 0xd5, 0xda, 0x8f, 0xee, 0xcd,
	0x46, 0x60, 0x1e, 0x04, 0xc7, 0x18, 0xda, 0x80, 0xad, 0x5b, 0x35, 0xc3, 0xcb, 0x72, 0x29, 0x17,
	0x26, 0x7d, 0x0a, 0x35, 0xf5, 0x26, 0x55, 0xb3, 0x38, 0xba, 0x91, 0xe3, 0x69, 0x3e, 0xc0, 0xb0,
	0x80, 0x9c, 0x29, 0xfd, 0x12, 0x48, 0x34, 0x4f, 0x7f, 0x52, 0x71, 0x3a, 0x1e, 0x44, 0xa9, 0x1a,
	0xca, 0x28, 0x53, 0xb7, 0xca, 0x77, 0xd7, 0x70, 0x0b, 0xe5, 0xaf, 0x0e, 0x22, 0x2d, 0x51, 0x3c,
	0x9d, 0x8f, 0xec, 0xfa, 0xa0, 0x75, 0xad, 0x00, 0x3b, 0xa0, 0x79, 0x65, 0x10, 0x69, 0xf3, 0x45,
	0x1d, 0xa0, 0x71, 0x34, 0x51, 0x43, 0x39, 0x88, 0x06, 0x3f, 0xa9, 0xc5, 0xe1, 0xf2, 0x03, 0xfa,
	0xb9, 0xd1, 0x44, 0x75, 0x31, 0x28, 0x4b, 0x41, 0xcc, 0x31, 0x03, 0xe4, 0xa9, 0xfe, 0x00, 0x8f,
	0x07, 0xe3, 0xe9, 0x50, 0x4e, 0xa3, 0xc1, 0x75, 0x34, 0x52, 0x3a, 0x4b, 0x99, 0x67, 0xcc, 0x3a,
	0xd2, 0x5a, 0xa7, 0xe3, 0xf8, 0xb6, 0x9f, 0x05, 0xaf, 0x24, 0x3e, 0xc4, 0x24, 0x39, 0xac, 0xdf,
	0xe3, 0xad, 0x3f, 0x43, 0x65, 0xc1, 0x9f, 0x3e, 0x83, 0xed, 0x78, 0x3e, 0xb9, 0x52, 0x33, 0x39,
	0x4e, 0xd5, 0x44, 0x9b, 0x1e, 0x94, 0x78, 0x2d, 0xc3, 0x1c, 0x84, 0x28, 0x85, 0x8d, 0xe5, 0xc2,
	0x28, 0x71, 0xf3, 0x4d, 0xbf, 0x85, 0x5a, 0x72, 0x33, 0x54, 0x3a, 0x5f, 0x07, 0xa5, 0x8f, 0xbe,
	0x6a, 0xc8, 0xc2, 0xcd, 0xc3, 0x7e, 0x03, 0xf5, 0x75, 0x09, 0xf0, 0x0a, 0x14, 0x21, 0x7f, 0x38,
	0xe6, 0xfb, 0xc1, 0x6b, 0x7f, 0x0f, 0x3b, 0x37, 0x91, 0x4e, 0xe5, 0x5c, 0xab, 0xff, 0xf7, 0xe2,
	0x1a, 0x1e, 0x08, 0xb5, 0x32, 0x37, 0xff, 0xa5, 0x00, 0x07, 0x0f, 0x6a, 0xf5, 0x20, 0x83, 0x0f,
	0xcf, 0xda, 0x82, 0x5b, 0xe9, 0x7f, 0x71, 0xdb, 0xf8, 0x65, 0xdc, 0xfe, 0x5e, 0x80, 0xca, 0x62,
	0x7f, 0xe1, 0xb6, 0x35, 0x1b, 0x2c, 0xcb, 0x54, 0xf8, 0xf8, 0xb6, 0x35, 0xd1, 0x66, 0xdb, 0xb6,
	0xa0, 0x74, 0x95, 0xa4, 0x86, 0x71, 0xad, 0x4d, 0xee, 0xbe, 0x40, 0x8e, 0x4e, 0xfa, 0x02, 0x36,
	0xcd, 0x01, 0x53, 0x40, 0xbd, 0xfd, 0xf8, 0xc1, 0x25, 0x6a, 0x96, 0x4b, 0x16, 0x87, 0xbf, 0x1c,
	0x19, 0x1f, 0x5c, 0x2d, 0xd9, 0xa3, 0xa9, 0x18, 0xa0, 0xaf, 0x47, 0xcf, 0xff, 0x55, 0x80, 0x9d,
	0xb5, 0x95, 0x44, 0x9b, 0x70, 0xd8, 0xf1, 0x84, 0x0c, 0x84, 0x25, 0xc2, 0x40, 0x86, 0x6e, 0xe0,
	0xb3, 0xae, 0xf3, 0xbd, 0xc3, 0x6c, 0xf2, 0x09, 0xad, 0xc1, 0x56, 0xdf, 0x09, 0x02, 0xc7, 0x7d,
	0x49, 0x0a, 0xf4, 0x31, 0x1c, 0xfc, 0x10, 0x5a, 0xdc, 0x72, 0x85, 0xe3, 0x32, 0x5b, 0x76, 0x2e,
	0x65, 0xc0, 0xf8, 0x39, 0xe3, 0xa4, 0x48, 0x0f, 0x81, 0xde, 0x71, 0x75, 0x3c, 0x41, 0x4a, 0xf4,
	0x19, 0x1c, 0x79, 0xe7, 0x8c, 0x9f, 0x31, 0xcb, 0x96, 0x7d, 0xcb, 0x71, 0x05, 0x73, 0x2d, 0xb7,
	0xcb, 0x24, 0xbb, 0x10, 0x8c, 0xbb, 0x56, 0x8f, 0x6c, 0x60, 0xd6, 0x65, 0x08, 0xf2, 0xc0, 0x20,
	0xe3, 0xda, 0xa4, 0x14, 0xea, 0x67, 0x5e, 0x20, 0x24, 0x67, 0x1d, 0xcf, 0x13, 0x48, 0xa2, 0x4c,
	0x2b, 0xb0, 0xd1, 0x09, 0x83, 0x4b, 0xb2, 0x45, 0xb7, 0xa1, 0xc2, 0x99, 0x61, 0x60, 0x93, 0x0a,
	0xe2, 0x8e, 0xdd, 0x63, 0xa4, 0xfa, 0xfc, 0xdf, 0x45, 0xd8, 0x5e, 0x95, 0x85, 0x7e, 0x0e, 0x4d,
	0x4c, 0xcc, 0xce, 0x99, 0x2b, 0xa4, 0xb8, 0xf4, 0xd9, 0x9d, 0x22, 0x3f, 0x85, 0x5d, 0xf4, 0xbb,
	0xec, 0x47, 0x19, 0xb0, 0x20, 0x70, 0x3c, 0x97, 0x14, 0x68, 0x03, 0xf6, 0x57, 0xd9, 0xc8, 0xef,
	0x2d, 0xa7, 0x17, 0x72, 0x46, 0x8a, 0xc8, 0x0a, 0x3d, 0x67, 0x9e, 0xf7, 0x4a, 0x32, 0xce, 0x3d,
	0x4e, 0x4a, 0x94, 0xc0, 0xf6, 0x12, 0xeb, 0x79, 0x2f, 0xc9, 0x06, 0x2a, 0x82, 0xc8, 0x92, 0xba,
	0xc4, 0x4a, 0xc8, 0xe6, 0x22, 0x32, 0x38, 0x0b, 0x85, 0xed, 0xfd, 0xe8, 0x92, 0x32, 0xdd, 0x83,
	0x1d, 0xc7, 0x0d, 0x04, 0x0f, 0xbb, 0x42, 0x9a, 0x12, 0x80, 0x3e, 0x82, 0x4f, 0x97, 0x50, 0x20,
	0x2c, 0x2e, 0xa4, 0xb0, 0x82, 0x57, 0xa4, 0x86, 0xac, 0x96, 0x0e, 0xce, 0x32, 0x17, 0x2a, 0xbd,
	0x4d, 0x3f, 0x83, 0xc6, 0xd2, 0x13, 0xfa, 0xb6, 0x25, 0x98, 0x51, 0xb3, 0xeb, 0xd9, 0x8c, 0xec,
	0x60, 0x8f, 0x97, 0x5e, 0xc1, 0x78, 0xdf, 0x71, 0xf3, 0x00, 0x52, 0xc7, 0x7a, 0x30, 0xbb, 0xec,
	0x7a, 0x7d, 0xbf, 0xc7, 0x04, 0xb3, 0xc9, 0x3e, 0x36, 0xc5, 0x60, 0xf7, 0xca, 0x3f, 0xa0, 0xbb,
	0x50, 0x33, 0xae, 0x57, 0x4e, 0xaf, 0xc7, 0x6c, 0x72, 0xf8, 0xfc, 0x1f, 0x05, 0xd8, 0xc3, 0x9f,
	0x23, 0x1c, 0x29, 0xd5, 0x8d, 0x52, 0x35, 0x4a, 0x66, 0x6f, 0xe9, 0x17, 0xf0, 0xd4, 0x84, 0xe1,
	0x58, 0x31, 0xd9, 0xb5, 0x04, 0x7b, 0xe9, 0xf1, 0xcb, 0xfb, 0xca, 0xaf, 0x04, 0xf5, 0xb1, 0xc6,
	0x5d, 0xba, 0x0f, 0x64, 0x19, 0xee, 0x33, 0xd7, 0xc6, 0xbe, 0x93, 0x35, 0x94, 0x87, 0xae, 0x8b,
	0xe8, 0x31, 0x7d, 0x02, 0x8f, 0x96, 0xa8, 0xe0, 0x96, 0x1b, 0x38, 0xd8, 0x63, 0xdb, 0x73, 0x19,
	0xf9, 0x6a, 0xcd, 0xc9, 0x2e, 0x58, 0x37, 0x14, 0x8e, 0xe7, 0x66, 0xce, 0xef, 0xd6, 0x9c, 0x2e,
	0x3b, 0x67, 0x5c, 0x72, 0x2b, 0x77, 0xfa, 0xcf, 0xff, 0x5a, 0x82, 0xea, 0xb2, 0x24, 0x6c, 0xe5,
	0x0a, 0x4b, 0xc7, 0x3d, 0xb7, 0x7a, 0x4e, 0xfe, 0x38, 0xd6, 0xf8, 0xe5, 0x86, 0xb4, 0x99, 0x1d,
	0xfa, 0x88, 0xee, 0x61, 0xc8, 0x7b, 0xb2, 0x4d, 0x38, 0xcc, 0x0d, 0xb9, 0x9c, 0xf8, 0x80, 0x89,
	0xd0, 0x27, 0xcf, 0xe8, 0x11, 0x3c, 0xbe, 0xe7, 0x13, 0xcc, 0xe2, 0x66, 0x46, 0x5a, 0x46, 0xf4,
	0xbc, 0x6d, 0x98, 0xeb, 0x0b, 0x5a, 0x07, 0xc8, 0xfb, 0x85, 0xf6, 0x0b, 0xbc, 0xfe, 0x5e, 0xaf,
	0xbe, 0xc2, 0x63, 0x76, 0x28, 0x96, 0xc0, 0xd7, 0x8b, 0x51, 0xb7, 0x9d, 0xc0, 0xf2, 0x7d, 0x66,
	0x71, 0x66, 0x93, 0x36, 0xdd, 0x81, 0xaa, 0xcf, 0x19, 0xeb, 0xfb, 0xd8, 0xfb, 0x6f, 0xd0, 0x7c,
	0x3f, 0x0a, 0xdf, 0xa1, 0x29, 0x9c, 0x3e, 0xb3, 0xa5, 0x17, 0x0a, 0x62, 0xd1, 0x03, 0xd8, 0x5b,
	0x9a, 0x32, 0x70, 0x7a, 0xcc, 0xed, 0x32, 0xd2, 0xa1, 0x00, 0xe5, 0x7c, 0x20, 0xba, 0x58, 0xb4,
	0x91, 0x80, 0xd9, 0xc4, 0x47, 0x83, 0x5d, 0xf8, 0x0e, 0xde, 0xf4, 0x03, 0x3e, 0xd9, 0x2e, 0xbe,
	0x7f, 0x8c, 0xe3, 0xc8, 0xce, 0xf5, 0x70, 0x8c, 0xbd, 0x90, 0x77, 0x19, 0x09, 0xf0, 0xaa, 0x9e,
	0x87, 0xa2, 0x9c, 0x31, 0x9b, 0x08, 0xd4, 0x7d, 0xe1, 0x94, 0xec, 0xe2, 0xcc, 0x0a, 0x03, 0x64,
	0x14, 0xb6, 0x03, 0x28, 0x77, 0x92, 0xd4, 0xf2, 0x1d, 0xea, 0x40, 0x39, 0xfb, 0xcb, 0x49, 0x8f,
	0x1e, 0xdc, 0x8a, 0x8b, 0xff, 0xd8, 0xcd, 0xcf, 0x3f, 0xe4, 0xce, 0xfe, 0xa9, 0xb6, 0x3e, 0xb9,
	0x2a, 0x9b, 0x45, 0xfd, 0xcd, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x90, 0x82, 0x30, 0xff,
	0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BotAPIClient is the client API for BotAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BotAPIClient interface {
	// Events returns events relating to one bot.
	Events(ctx context.Context, in *BotEventsRequest, opts ...grpc.CallOption) (*BotEventsResponse, error)
}
type botAPIPRPCClient struct {
	client *prpc.Client
}

func NewBotAPIPRPCClient(client *prpc.Client) BotAPIClient {
	return &botAPIPRPCClient{client}
}

func (c *botAPIPRPCClient) Events(ctx context.Context, in *BotEventsRequest, opts ...grpc.CallOption) (*BotEventsResponse, error) {
	out := new(BotEventsResponse)
	err := c.client.Call(ctx, "swarming.v1.BotAPI", "Events", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type botAPIClient struct {
	cc *grpc.ClientConn
}

func NewBotAPIClient(cc *grpc.ClientConn) BotAPIClient {
	return &botAPIClient{cc}
}

func (c *botAPIClient) Events(ctx context.Context, in *BotEventsRequest, opts ...grpc.CallOption) (*BotEventsResponse, error) {
	out := new(BotEventsResponse)
	err := c.cc.Invoke(ctx, "/swarming.v1.BotAPI/Events", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BotAPIServer is the server API for BotAPI service.
type BotAPIServer interface {
	// Events returns events relating to one bot.
	Events(context.Context, *BotEventsRequest) (*BotEventsResponse, error)
}

func RegisterBotAPIServer(s prpc.Registrar, srv BotAPIServer) {
	s.RegisterService(&_BotAPI_serviceDesc, srv)
}

func _BotAPI_Events_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BotAPIServer).Events(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swarming.v1.BotAPI/Events",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BotAPIServer).Events(ctx, req.(*BotEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BotAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "swarming.v1.BotAPI",
	HandlerType: (*BotAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Events",
			Handler:    _BotAPI_Events_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "swarming.proto",
}
