<!--
Copyright 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="ct-commit-list.html">
<link rel="import" href="ct-tree-list.html">

<script>
function CTFailureGroup(tree, data, category) {
  this.key = data.key;
  this.tree = tree;
  this.examineUrl = this.tree + '/failure/' + encodeURIComponent(this.key);
  this.data = data;
  this._originalCategory = category || 'default';
  // This will set |category| which is used for grouping so it is convenient
  // to make sure that it is set on construction.
  this._computeProperties();
  var cTree = CTTreeList.getTree(tree).then(function(cTree) {
    if (cTree)
      this.data.bugLabels = cTree.bugLabels;
  }.bind(this))
}

CTFailureGroup.transientProperties = ['category', 'snoozed', 'bug', 'bugLabel'];


CTFailureGroup.prototype._isTreeCloser = function() {
  return this.data.isTreeCloser && this.data.isTreeCloser();
}

CTFailureGroup.prototype._failedOnce = function() {
  return this.data.failedOnce && this.data.failedOnce();
}

CTFailureGroup.Category = {
  SNOOZED: 'snoozed',
  TREE_CLOSER: 'treeCloser',
  FAILED_ONCE: 'failedOnce',
};

CTFailureGroup.prototype._computeProperties = function() {
  var annotations = CTFailureGroup._annotations[this.key];
  if (annotations == null) {
    this.isSnoozed = false;
    this.category = this._originalCategory;
    return;
  }

  annotations = CTFailureGroup._mergeAnnotations(annotations);

  this.isSnoozed = annotations.snoozeTime ?
    Date.now() < annotations.snoozeTime : false;
  if (this.isSnoozed) {
    this.category = CTFailureGroup.Category.SNOOZED;
  } else if (this._isTreeCloser()) {
    this.category = CTFailureGroup.Category.TREE_CLOSER;
  } else if (this._failedOnce()) {
    this.category = CTFailureGroup.Category.FAILED_ONCE;
  } else {
    this.category = this._originalCategory;
  }

  // FIXME: Allow multiple bugs
  this.bug = annotations.bugs ? annotations.bugs[0] : null;
  var bugId = /([0-9]{3,})/.exec(this.bug);

  // FIXME: Bug labels would be simpler to implement as a filter in the UI.
  this.bugLabel = this.bug ? `Bug ${bugId[0]}` : undefined;
};

CTFailureGroup._mergeAnnotations = function(annotations) {
  var bugs;
  if (annotations != null && annotations.bugs != null) {
    bugs = [annotations.bugs.compact().first()];
  }

  // The group is only snoozed if all the failures specify a snooze-time, and
  // only until the first has elapsed.
  var snoozeTime = annotations && annotations.snoozeTime;

  return {
    bugs: bugs,
    snoozeTime: snoozeTime,
  };
};

CTFailureGroup.prototype.snoozeUntil = function(time) {
  return this._addAnnotation({snoozeTime: time});
};

CTFailureGroup.prototype.unsnooze = function() {
  return this._removeAnnotation({snoozeTime: true});
};

CTFailureGroup.prototype.setBug = function(bug) {
  // TODO: notify user when the server rejects our bug
  if (this.bug) {
    this.clearBug().then(function(data) {
      this._addAnnotation({
        bugs: [bug],
      });
    }.bind(this));
  } else {
    return this._addAnnotation({
      bugs: [bug],
    });
  }
};

CTFailureGroup.prototype.clearBug = function() {
  return this._removeAnnotation({
    bugs: [this.bug],
  });
};

CTFailureGroup.prototype._addAnnotation = function(change) {
  return this._updateAnnotation('add', change);
};

CTFailureGroup.prototype._removeAnnotation = function(change) {
  return this._updateAnnotation('remove', change);
};

CTFailureGroup.prototype._updateAnnotation = function(kind, change) {
  var fullChange = [{kind: change}];

  return net.ajax({
    type: 'POST',
    data: JSON.stringify(fullChange),
    url: '/api/v1/annotations/' + this.key,
  }).then(function(data) {
    var parsed = JSON.parse(data);
    CTFailureGroup._annotations[parsed.key] = parsed;
    this._computeProperties();
  }.bind(this));
};


CTFailureGroup.prototype.fetchAnnotations = function() {
  return net.json('/api/v1/annotations/' + this.key).then(function(data) {
    CTFailureGroup._annotations[data.key] = data;
    this._computeProperties();
  }.bind(this));
};

CTFailureGroup.fetchAllAnnotations = function() {
  return net.json('/api/v1/annotations').then(function(data) {
    if (CTFailureGroup._annotations == null) {
      CTFailureGroup._annotations = {};
    }

    data.forEach(function(annotation) {
      CTFailureGroup._annotations[annotation.key] = annotation;
    })
    return data;
  });
};

</script>
