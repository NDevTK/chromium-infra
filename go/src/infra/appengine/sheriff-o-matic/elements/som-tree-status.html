<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/iron-ajax/iron-ajax.html">

<dom-module id="som-tree-status">
  <template>
    <style>
    #error,
    #treeClosed {
      box-sizing: border-box;
      width: 100%;
      padding: 8px 10px;
      margin: 5px auto;
      border: 1px solid #dcdcdc;
      color: #fff;
      background-color: #E75D54;
      border-radius: 5px;
    }
    a, a:active, a:visited {
      color: #fff;
    }
    </style>
    <iron-ajax
      id="treeStatus"
      url="[[_statusUrl]]/current?format=json"
      handle-as="json"
      last-error="{{_statusErrorJson}}"
      last-response="{{_statusJson}}"
      debounce-duration="300"></iron-ajax>
    <div id="error" hidden$="[[!_hasError]]">
      Error fetching tree status from <a href="[[_statusUrl]]" target="_blank">[[_statusUrl]]</a>
    </div>
    <div id="treeClosed" hidden$="[[_hideNotice]]">
      <template is="dom-repeat" items="[[_computeMessageFragments(_message)]]" as="fragment">
        <template is="dom-if" if="[[fragment.link]]"><a href="[[fragment.link]]" target="_blank">[[fragment.linkText]]</a></template>[[fragment.text]]
      </template>
      by <a href="mailto:[[_email]]">[[_username]]</a> on [[_time]] (<a href="[[_statusUrl]]" target="_blank">More</a>)
    </div>
  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'som-tree-status',

      properties: {
        tree: {
          type: String,
          observer: 'refresh',
        },
        _hasError: {
          type: Boolean,
          computed: '_computeHasError(_hasStatusApp, _statusErrorJson)',
          value: false,
        },
        _hasStatusApp: {
          type: Boolean,
          computed: '_computeHasStatusApp(tree, _statusApps)',
        },
        _hideNotice: {
          type: Boolean,
          computed: '_computeHideNotice(_hasStatusApp, _isClosed, _hasError)',
          value: true,
        },
        _statusApps: {
          type: Object,
          value: {
            'chromium': 'https://chromium-status.appspot.com',
            'chromiumos': 'https://chromiumos-status.appspot.com',
          },
        },
        _statusErrorJson: Object,
        _statusJson: Object,
        _statusUrl: {
          type: String,
          computed: '_computeStatusUrl(tree, _statusApps)',
        },
        // Processed JSON data
        _email: {
          type: String,
          computed: '_computeEmail(_statusJson)',
        },
        _isClosed: {
          type: Boolean,
          value: false,
          computed: '_computeIsClosed(_statusJson)',
        },
        _message: {
          type: String,
          computed: '_computeMessage(_statusJson)',
        },
        _time: {
          type: String,
          computed: '_computeTime(_statusJson)',
        },
        _username: {
          type: String,
          computed: '_computeUsername(_email)',
        },
      },

      refresh: function() {
        if (!this._hasStatusApp) {
          return;
        }
        this.$.treeStatus.generateRequest();
      },

      _computeHasError: function(hasStatusApp, json) {
        return hasStatusApp && !!json && Object.keys(json).length > 0;
      },

      _computeHasStatusApp: function(tree, statusApps) {
        return tree in statusApps;
      },

      _computeHideNotice: function(hasStatusApp, isClosed, hasError) {
        return !hasStatusApp || !isClosed || hasError;
      },

      _computeStatusUrl: function(tree, statusApps) {
        if (!this._hasStatusApp) {
          return '';
        }

        return statusApps[tree];
      },

      // Processing JSON data for display
      _computeEmail(json) {
        if (!json || !json.username) {
          return '';
        }
        return json.username;
      },

      _computeIsClosed(json) {
        if (!json || !json.general_state) {
          return false;
        }
        return json.general_state === 'closed';
      },

      _computeMessage(json) {
        if (!json || !json.message) {
          return 'Unknown';
        }
        return json.message;
      },

      // To add links to status messages without injecting arbitrary HTML, we're
      // splitting the message up into fragments that Polymer iterates through.
      // A message fragment is treated as a link if the link property is set
      _computeMessageFragments(message) {
        if (!message) {
          return [];
        }

        // Regex is bad but the data is unstructured.
        let emailRegex = /((^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+)@([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$))/;
        let urlRegex = /(https?:\/\/(www\.)?([-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6})\b([-a-zA-Z0-9@:%_\+.~#?&//=]*))/;

        // Commas are included because they are often used to delimit emails
        let words = message.split(/(\s|,)/);
        let currentFragment = '';
        let result = [];
        for (let i in words) {
          let w = words[i];
          let emailMatch = w.match(emailRegex);
          let urlMatch = w.match(urlRegex);

          if (emailMatch || urlMatch) {
            if (currentFragment !== '') {
              result.push({text: currentFragment});
              currentFragment = '';
            }

            if (emailMatch) {
              result.push({
                // Capture group for the "username" section of the email
                linkText: emailMatch[2],
                link: 'mailto:' + emailMatch[0], // The whole email
              });
            } else if (urlMatch) {
              result.push({
                // Capture group for the domain/subdomain section of the link
                linkText: urlMatch[3],
                link: urlMatch[1], // The whole link
              });
            }
          } else {
            currentFragment += w;
          }
        }
        // Add trailing fragment
        if (currentFragment !== '') {
          result.push(currentFragment);
        }
        return result;
      },

      _computeTime(json) {
        if (!json || !json.date) {
          return 'Unknown';
        }
        return json.date + " GMT";
      },

      _computeUsername(email) {
        let cutoff = email.indexOf("@");
        if (cutoff < 0) {
          return 'Unknown';
        }
        return email.substring(0, cutoff);
      },
    });
  })();
  </script>
</dom-module>
