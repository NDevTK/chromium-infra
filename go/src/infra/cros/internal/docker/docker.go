// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package docker provides helper methods for ChromeOS usage of Docker.
package docker

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
	"github.com/pkg/errors"
	"go.chromium.org/chromiumos/config/go/build/api"
	"go.chromium.org/luci/common/logging"
)

// PullImage pulls the Docker image specified by containerImageInfo.
//
// Authentication to the registry is done via a password generated by
// `gcloud auth print-access-token`.
func PullImage(ctx context.Context, client client.ImageAPIClient, containerImageInfo api.ContainerImageInfo) error {
	passwordCmd := exec.CommandContext(ctx, "gcloud", "auth", "print-access-token")

	var stdoutWriter bytes.Buffer
	passwordCmd.Stdout = &stdoutWriter

	err := passwordCmd.Run()
	if err != nil {
		return errors.New("failed to get gcloud access token with 'gcloud auth print-access-token'")
	}

	authConfig := types.AuthConfig{
		Username:      "oauth2accesstoken",
		Password:      strings.TrimSpace(stdoutWriter.String()),
		ServerAddress: containerImageInfo.GetRepository().GetHostname(),
	}

	encodedJSON, err := json.Marshal(authConfig)
	if err != nil {
		return errors.New("failed to marshal auth config to json")
	}

	imageName := fmt.Sprintf(
		"%s/%s/%s@%s",
		containerImageInfo.GetRepository().GetHostname(),
		containerImageInfo.GetRepository().GetProject(),
		containerImageInfo.GetName(),
		containerImageInfo.GetDigest(),
	)

	resp, err := client.ImagePull(
		ctx,
		imageName,
		types.ImagePullOptions{
			RegistryAuth: base64.URLEncoding.EncodeToString(encodedJSON),
		},
	)
	if err != nil {
		return err
	}

	defer resp.Close()

	type PullResponse struct {
		Status string `json:"status,omitempty"`
	}

	dec := json.NewDecoder(resp)
	for dec.More() {
		var r PullResponse

		err := dec.Decode(&r)
		if err != nil {
			return errors.Wrap(err, "failed decoding PullImage response")
		}

		logging.Infof(ctx, r.Status)
	}

	return nil
}

// RunContainer creates and starts a container, waits until the command
// completes, and copies the container std[out,err] to the host std[out,err].
//
// This function calls methods on client for the common case of starting a
// single container and waiting for it to exit.
//
// A ContainerWaitOKBody from the ContainerWait call is returned.
func RunContainer(
	ctx context.Context,
	client client.ContainerAPIClient,
	containerConfig *container.Config,
	hostConfig *container.HostConfig,
) (*container.ContainerWaitOKBody, error) {
	createResp, err := client.ContainerCreate(
		ctx, containerConfig, hostConfig, nil, nil, "",
	)
	if err != nil {
		return nil, errors.Wrap(err, "creating Docker container failed")
	}

	logging.Infof(ctx, "created Docker container, ID: %s", createResp.ID)

	for _, warning := range createResp.Warnings {
		logging.Warningf(ctx, "creating Docker container: %s", warning)
	}

	err = client.ContainerStart(ctx, createResp.ID, types.ContainerStartOptions{})
	if err != nil {
		return nil, errors.Wrap(err, "starting Docker container failed")
	}

	waitRespC, errC := client.ContainerWait(ctx, createResp.ID, container.WaitConditionNotRunning)

	var waitResp container.ContainerWaitOKBody

	select {
	case err := <-errC:
		return nil, errors.Wrap(err, "waiting for Docker container failed")
	case waitResp = <-waitRespC:
		if waitResp.Error != nil && waitResp.Error.Message != "" {
			logging.Errorf(ctx, "error running Docker container: %s", waitResp.Error.Message)
		}
	}

	logs, err := client.ContainerLogs(ctx, createResp.ID, types.ContainerLogsOptions{ShowStdout: true, ShowStderr: true})
	if err != nil {
		return nil, errors.Wrap(err, "fetching logs from Docker container failed")
	}

	_, err = stdcopy.StdCopy(os.Stdout, os.Stderr, logs)
	if err != nil {
		return nil, errors.Wrap(err, "copying logs to host stdout and stderr failed")
	}

	return &waitResp, nil
}
