// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package assertions

import (
	"fmt"

	"github.com/GoogleCloudPlatform/go-endpoints/endpoints"

	"github.com/luci/luci-go/common/testing/assertions"
	"github.com/smartystreets/goconvey/convey"
)

// ShouldHaveAPIError is a goconvey assertion, asserting that the supplied
// "actual" value is an *endpoints.APIError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldHaveAPIError(actual interface{}, expected ...interface{}) string {
	if len(expected) != 1 {
		return "exactly one expected argument must be supplied, and it must be an *endpoints.APIError."
	}
	eerr, ok := expected[0].(*endpoints.APIError)
	if !ok {
		return "expected argument must be an *endpoints.APIError."
	}

	if err := convey.ShouldHaveSameTypeAs(actual, (*endpoints.APIError)(nil)); err != "" {
		return err
	}

	aerr := actual.(*endpoints.APIError)

	// Create copies and strip the messages so we can compare values. We do this
	// rather than assert individual properties because the joint output is nicer
	// to look at.
	aerrCopy := *aerr
	aerrCopy.Msg = ""

	eerrCopy := *eerr
	eerrCopy.Msg = ""

	if err := convey.ShouldResemble(aerrCopy, eerrCopy); err != "" {
		return err
	}

	// If a ShouldErrLike string was supplied, compare that, too.
	if eerr.Msg != "" {
		return assertions.ShouldErrLike(aerr, eerr.Msg)
	}
	return ""
}

// ShouldBeInternalServerError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewInternalServerError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeInternalServerError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewInternalServerError(msg))
}

// ShouldBeBadRequestError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewBadRequestError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeBadRequestError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewBadRequestError(msg))
}

// ShouldBeUnauthorizedError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewUnauthorizedError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeUnauthorizedError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewUnauthorizedError(msg))
}

// ShouldBeNotFoundError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewNotFoundError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeNotFoundError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewNotFoundError(msg))
}

// ShouldBeForbiddenError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewForbiddenError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeForbiddenError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewForbiddenError(msg))
}

// ShouldBeConflictError asserts that "actual" is an *endpoints.APIError
// generated by endpoints.NewConflictError.
//
// One additional "expected" string may be optionally included. If included, the
// *endpoints.APIError's message is asserted to contain the expected string
// using ShouldErrorLike.
func ShouldBeConflictError(actual interface{}, expected ...interface{}) string {
	msg, err := getErrLikeMsg(expected)
	if err != "" {
		return err
	}
	return ShouldHaveAPIError(actual, endpoints.NewConflictError(msg))
}

func getErrLikeMsg(expected []interface{}) (string, string) {
	switch len(expected) {
	case 0:
		return "", ""
	case 1:
		s, ok := expected[0].(string)
		if !ok {
			return "", fmt.Sprintf("expected message must be string, not %T", expected[0])
		}
		return s, ""

	default:
		return "", "expected must have at most one argument"
	}
}
